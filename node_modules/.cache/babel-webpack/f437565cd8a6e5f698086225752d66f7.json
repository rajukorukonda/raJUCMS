{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { fromEvent, Subject } from 'rxjs';\nimport { debounceTime, takeUntil } from 'rxjs/operators';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport { merge } from 'lodash-es';\nimport { ScrollbarGeometry, ScrollbarPosition } from '@fuse/directives/scrollbar/scrollbar.types';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/platform\";\nimport * as i2 from \"@angular/router\";\n/**\r\n * Wrapper directive for the Perfect Scrollbar: https://github.com/mdbootstrap/perfect-scrollbar\r\n */\nexport let FuseScrollbarDirective = /*#__PURE__*/(() => {\n  class FuseScrollbarDirective {\n    /**\r\n     * Constructor\r\n     */\n    constructor(_elementRef, _platform, _router) {\n      this._elementRef = _elementRef;\n      this._platform = _platform;\n      this._router = _router;\n      /* eslint-enable @typescript-eslint/naming-convention */\n      this.fuseScrollbar = true;\n      this._unsubscribeAll = new Subject();\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Getter for _elementRef\r\n     */\n    get elementRef() {\n      return this._elementRef;\n    }\n    /**\r\n     * Getter for _ps\r\n     */\n    get ps() {\n      return this._ps;\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Lifecycle hooks\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * On changes\r\n     *\r\n     * @param changes\r\n     */\n    ngOnChanges(changes) {\n      // Enabled\n      if ('fuseScrollbar' in changes) {\n        // Interpret empty string as 'true'\n        this.fuseScrollbar = coerceBooleanProperty(changes.fuseScrollbar.currentValue);\n        // If enabled, init the directive\n        if (this.fuseScrollbar) {\n          this._init();\n        }\n        // Otherwise destroy it\n        else {\n          this._destroy();\n        }\n      }\n      // Scrollbar options\n      if ('fuseScrollbarOptions' in changes) {\n        // Merge the options\n        this._options = merge({}, this._options, changes.fuseScrollbarOptions.currentValue);\n        // Return if not initialized\n        if (!this._ps) {\n          return;\n        }\n        // Destroy and re-init the PerfectScrollbar to update its options\n        setTimeout(() => {\n          this._destroy();\n        });\n        setTimeout(() => {\n          this._init();\n        });\n      }\n    }\n    /**\r\n     * On init\r\n     */\n    ngOnInit() {\n      // Subscribe to window resize event\n      fromEvent(window, 'resize').pipe(takeUntil(this._unsubscribeAll), debounceTime(150)).subscribe(() => {\n        // Update the PerfectScrollbar\n        this.update();\n      });\n    }\n    /**\r\n     * On destroy\r\n     */\n    ngOnDestroy() {\n      this._destroy();\n      // Unsubscribe from all subscriptions\n      this._unsubscribeAll.next();\n      this._unsubscribeAll.complete();\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Is enabled\r\n     */\n    isEnabled() {\n      return this.fuseScrollbar;\n    }\n    /**\r\n     * Update the scrollbar\r\n     */\n    update() {\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      }\n      // Update the PerfectScrollbar\n      this._ps.update();\n    }\n    /**\r\n     * Destroy the scrollbar\r\n     */\n    destroy() {\n      this.ngOnDestroy();\n    }\n    /**\r\n     * Returns the geometry of the scrollable element\r\n     *\r\n     * @param prefix\r\n     */\n    geometry(prefix = 'scroll') {\n      return new ScrollbarGeometry(this._elementRef.nativeElement[prefix + 'Left'], this._elementRef.nativeElement[prefix + 'Top'], this._elementRef.nativeElement[prefix + 'Width'], this._elementRef.nativeElement[prefix + 'Height']);\n    }\n    /**\r\n     * Returns the position of the scrollable element\r\n     *\r\n     * @param absolute\r\n     */\n    position(absolute = false) {\n      let scrollbarPosition;\n      if (!absolute && this._ps) {\n        scrollbarPosition = new ScrollbarPosition(this._ps.reach.x || 0, this._ps.reach.y || 0);\n      } else {\n        scrollbarPosition = new ScrollbarPosition(this._elementRef.nativeElement.scrollLeft, this._elementRef.nativeElement.scrollTop);\n      }\n      return scrollbarPosition;\n    }\n    /**\r\n     * Scroll to\r\n     *\r\n     * @param x\r\n     * @param y\r\n     * @param speed\r\n     */\n    scrollTo(x, y, speed) {\n      if (y == null && speed == null) {\n        this.animateScrolling('scrollTop', x, speed);\n      } else {\n        if (x != null) {\n          this.animateScrolling('scrollLeft', x, speed);\n        }\n        if (y != null) {\n          this.animateScrolling('scrollTop', y, speed);\n        }\n      }\n    }\n    /**\r\n     * Scroll to X\r\n     *\r\n     * @param x\r\n     * @param speed\r\n     */\n    scrollToX(x, speed) {\n      this.animateScrolling('scrollLeft', x, speed);\n    }\n    /**\r\n     * Scroll to Y\r\n     *\r\n     * @param y\r\n     * @param speed\r\n     */\n    scrollToY(y, speed) {\n      this.animateScrolling('scrollTop', y, speed);\n    }\n    /**\r\n     * Scroll to top\r\n     *\r\n     * @param offset\r\n     * @param speed\r\n     */\n    scrollToTop(offset = 0, speed) {\n      this.animateScrolling('scrollTop', offset, speed);\n    }\n    /**\r\n     * Scroll to bottom\r\n     *\r\n     * @param offset\r\n     * @param speed\r\n     */\n    scrollToBottom(offset = 0, speed) {\n      const top = this._elementRef.nativeElement.scrollHeight - this._elementRef.nativeElement.clientHeight;\n      this.animateScrolling('scrollTop', top - offset, speed);\n    }\n    /**\r\n     * Scroll to left\r\n     *\r\n     * @param offset\r\n     * @param speed\r\n     */\n    scrollToLeft(offset = 0, speed) {\n      this.animateScrolling('scrollLeft', offset, speed);\n    }\n    /**\r\n     * Scroll to right\r\n     *\r\n     * @param offset\r\n     * @param speed\r\n     */\n    scrollToRight(offset = 0, speed) {\n      const left = this._elementRef.nativeElement.scrollWidth - this._elementRef.nativeElement.clientWidth;\n      this.animateScrolling('scrollLeft', left - offset, speed);\n    }\n    /**\r\n     * Scroll to element\r\n     *\r\n     * @param qs\r\n     * @param offset\r\n     * @param ignoreVisible If true, scrollToElement won't happen if element is already inside the current viewport\r\n     * @param speed\r\n     */\n    scrollToElement(qs, offset = 0, ignoreVisible = false, speed) {\n      const element = this._elementRef.nativeElement.querySelector(qs);\n      if (!element) {\n        return;\n      }\n      const elementPos = element.getBoundingClientRect();\n      const scrollerPos = this._elementRef.nativeElement.getBoundingClientRect();\n      if (this._elementRef.nativeElement.classList.contains('ps--active-x')) {\n        if (ignoreVisible && elementPos.right <= scrollerPos.right - Math.abs(offset)) {\n          return;\n        }\n        const currentPos = this._elementRef.nativeElement['scrollLeft'];\n        const position = elementPos.left - scrollerPos.left + currentPos;\n        this.animateScrolling('scrollLeft', position + offset, speed);\n      }\n      if (this._elementRef.nativeElement.classList.contains('ps--active-y')) {\n        if (ignoreVisible && elementPos.bottom <= scrollerPos.bottom - Math.abs(offset)) {\n          return;\n        }\n        const currentPos = this._elementRef.nativeElement['scrollTop'];\n        const position = elementPos.top - scrollerPos.top + currentPos;\n        this.animateScrolling('scrollTop', position + offset, speed);\n      }\n    }\n    /**\r\n     * Animate scrolling\r\n     *\r\n     * @param target\r\n     * @param value\r\n     * @param speed\r\n     */\n    animateScrolling(target, value, speed) {\n      if (this._animation) {\n        window.cancelAnimationFrame(this._animation);\n        this._animation = null;\n      }\n      if (!speed || typeof window === 'undefined') {\n        this._elementRef.nativeElement[target] = value;\n      } else if (value !== this._elementRef.nativeElement[target]) {\n        let newValue = 0;\n        let scrollCount = 0;\n        let oldTimestamp = performance.now();\n        let oldValue = this._elementRef.nativeElement[target];\n        const cosParameter = (oldValue - value) / 2;\n        const step = newTimestamp => {\n          scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n          newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n          // Only continue animation if scroll position has not changed\n          if (this._elementRef.nativeElement[target] === oldValue) {\n            if (scrollCount >= Math.PI) {\n              this.animateScrolling(target, value, 0);\n            } else {\n              this._elementRef.nativeElement[target] = newValue;\n              // On a zoomed out page the resulting offset may differ\n              oldValue = this._elementRef.nativeElement[target];\n              oldTimestamp = newTimestamp;\n              this._animation = window.requestAnimationFrame(step);\n            }\n          }\n        };\n        window.requestAnimationFrame(step);\n      }\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Initialize\r\n     *\r\n     * @private\r\n     */\n    _init() {\n      // Return if already initialized\n      if (this._ps) {\n        return;\n      }\n      // Return if on mobile or not on browser\n      if (this._platform.ANDROID || this._platform.IOS || !this._platform.isBrowser) {\n        this.fuseScrollbar = false;\n        return;\n      }\n      // Initialize the PerfectScrollbar\n      this._ps = new PerfectScrollbar(this._elementRef.nativeElement, Object.assign({}, this._options));\n    }\n    /**\r\n     * Destroy\r\n     *\r\n     * @private\r\n     */\n    _destroy() {\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      }\n      // Destroy the PerfectScrollbar\n      this._ps.destroy();\n      // Clean up\n      this._ps = null;\n    }\n  }\n  FuseScrollbarDirective.ɵfac = function FuseScrollbarDirective_Factory(t) {\n    return new (t || FuseScrollbarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform), i0.ɵɵdirectiveInject(i2.Router));\n  };\n  FuseScrollbarDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: FuseScrollbarDirective,\n    selectors: [[\"\", \"fuseScrollbar\", \"\"]],\n    inputs: {\n      fuseScrollbar: \"fuseScrollbar\",\n      fuseScrollbarOptions: \"fuseScrollbarOptions\"\n    },\n    exportAs: [\"fuseScrollbar\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FuseScrollbarDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}