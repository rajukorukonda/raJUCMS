{"ast":null,"code":"import { BehaviorSubject, of } from 'rxjs';\nimport { map, switchMap, take, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let CalendarService = /*#__PURE__*/(() => {\n  class CalendarService {\n    /**\r\n     * Constructor\r\n     */\n    constructor(_httpClient) {\n      this._httpClient = _httpClient;\n      // Private\n      this._calendars = new BehaviorSubject(null);\n      this._events = new BehaviorSubject(null);\n      this._loadedEventsRange = {\n        start: null,\n        end: null\n      };\n      this._numberOfDaysToPrefetch = 60;\n      this._settings = new BehaviorSubject(null);\n      this._weekdays = new BehaviorSubject(null);\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Getter for calendars\r\n     */\n    get calendars$() {\n      return this._calendars.asObservable();\n    }\n    /**\r\n     * Getter for events\r\n     */\n    get events$() {\n      return this._events.asObservable();\n    }\n    /**\r\n     * Getter for settings\r\n     */\n    get settings$() {\n      return this._settings.asObservable();\n    }\n    /**\r\n     * Getter for weekdays\r\n     */\n    get weekdays$() {\n      return this._weekdays.asObservable();\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Get calendars\r\n     */\n    getCalendars() {\n      return this._httpClient.get('api/apps/calendar/calendars').pipe(tap(response => {\n        this._calendars.next(response);\n      }));\n    }\n    /**\r\n     * Add calendar\r\n     *\r\n     * @param calendar\r\n     */\n    addCalendar(calendar) {\n      return this.calendars$.pipe(take(1), switchMap(calendars => this._httpClient.post('api/apps/calendar/calendars', {\n        calendar\n      }).pipe(map(addedCalendar => {\n        // Add the calendar\n        calendars.push(addedCalendar);\n        // Update the calendars\n        this._calendars.next(calendars);\n        // Return the added calendar\n        return addedCalendar;\n      }))));\n    }\n    /**\r\n     * Update calendar\r\n     *\r\n     * @param id\r\n     * @param calendar\r\n     */\n    updateCalendar(id, calendar) {\n      return this.calendars$.pipe(take(1), switchMap(calendars => this._httpClient.patch('api/apps/calendar/calendars', {\n        id,\n        calendar\n      }).pipe(map(updatedCalendar => {\n        // Find the index of the updated calendar\n        const index = calendars.findIndex(item => item.id === id);\n        // Update the calendar\n        calendars[index] = updatedCalendar;\n        // Update the calendars\n        this._calendars.next(calendars);\n        // Return the updated calendar\n        return updatedCalendar;\n      }))));\n    }\n    /**\r\n     * Delete calendar\r\n     *\r\n     * @param id\r\n     */\n    deleteCalendar(id) {\n      return this.calendars$.pipe(take(1), switchMap(calendars => this._httpClient.delete('api/apps/calendar/calendars', {\n        params: {\n          id\n        }\n      }).pipe(map(isDeleted => {\n        // Find the index of the deleted calendar\n        const index = calendars.findIndex(item => item.id === id);\n        // Delete the calendar\n        calendars.splice(index, 1);\n        // Update the calendars\n        this._calendars.next(calendars);\n        // Remove the events belong to deleted calendar\n        const events = this._events.value.filter(event => event.calendarId !== id);\n        // Update the events\n        this._events.next(events);\n        // Return the deleted status\n        return isDeleted;\n      }))));\n    }\n    /**\r\n     * Get events\r\n     *\r\n     * @param start\r\n     * @param end\r\n     * @param replace\r\n     */\n    getEvents(start, end, replace = false) {\n      // Set the new start date for loaded events\n      if (replace || !this._loadedEventsRange.start || start.isBefore(this._loadedEventsRange.start)) {\n        this._loadedEventsRange.start = start;\n      }\n      // Set the new end date for loaded events\n      if (replace || !this._loadedEventsRange.end || end.isAfter(this._loadedEventsRange.end)) {\n        this._loadedEventsRange.end = end;\n      }\n      // Get the events\n      return this._httpClient.get('api/apps/calendar/events', {\n        params: {\n          start: start.toISOString(true),\n          end: end.toISOString(true)\n        }\n      }).pipe(switchMap(response => this._events.pipe(take(1), map(events => {\n        // If replace...\n        if (replace) {\n          // Execute the observable with the response replacing the events object\n          this._events.next(response);\n        }\n        // Otherwise...\n        else {\n          // If events is null, replace it with an empty array\n          events = events || [];\n          // Execute the observable by appending the response to the current events\n          this._events.next([...events, ...response]);\n        }\n        // Return the response\n        return response;\n      }))));\n    }\n    /**\r\n     * Reload events using the loaded events range\r\n     */\n    reloadEvents() {\n      // Get the events\n      return this._httpClient.get('api/apps/calendar/events', {\n        params: {\n          start: this._loadedEventsRange.start.toISOString(),\n          end: this._loadedEventsRange.end.toISOString()\n        }\n      }).pipe(map(response => {\n        // Execute the observable with the response replacing the events object\n        this._events.next(response);\n        // Return the response\n        return response;\n      }));\n    }\n    /**\r\n     * Prefetch future events\r\n     *\r\n     * @param end\r\n     */\n    prefetchFutureEvents(end) {\n      // Calculate the remaining prefetched days\n      const remainingDays = this._loadedEventsRange.end.diff(end, 'days');\n      // Return if remaining days is bigger than the number\n      // of days to prefetch. This means we were already been\n      // there and fetched the events data so no need for doing\n      // it again.\n      if (remainingDays >= this._numberOfDaysToPrefetch) {\n        return of([]);\n      }\n      // Figure out the start and end dates\n      const start = this._loadedEventsRange.end.clone().add(1, 'day');\n      end = this._loadedEventsRange.end.clone().add(this._numberOfDaysToPrefetch - remainingDays, 'days');\n      // Prefetch the events\n      return this.getEvents(start, end);\n    }\n    /**\r\n     * Prefetch past events\r\n     *\r\n     * @param start\r\n     */\n    prefetchPastEvents(start) {\n      // Calculate the remaining prefetched days\n      const remainingDays = start.diff(this._loadedEventsRange.start, 'days');\n      // Return if remaining days is bigger than the number\n      // of days to prefetch. This means we were already been\n      // there and fetched the events data so no need for doing\n      // it again.\n      if (remainingDays >= this._numberOfDaysToPrefetch) {\n        return of([]);\n      }\n      // Figure out the start and end dates\n      start = this._loadedEventsRange.start.clone().subtract(this._numberOfDaysToPrefetch - remainingDays, 'days');\n      const end = this._loadedEventsRange.start.clone().subtract(1, 'day');\n      // Prefetch the events\n      return this.getEvents(start, end);\n    }\n    /**\r\n     * Add event\r\n     *\r\n     * @param event\r\n     */\n    addEvent(event) {\n      return this.events$.pipe(take(1), switchMap(events => this._httpClient.post('api/apps/calendar/event', {\n        event\n      }).pipe(map(addedEvent => {\n        // Update the events\n        this._events.next(events);\n        // Return the added event\n        return addedEvent;\n      }))));\n    }\n    /**\r\n     * Update event\r\n     *\r\n     * @param id\r\n     * @param event\r\n     */\n    updateEvent(id, event) {\n      return this.events$.pipe(take(1), switchMap(events => this._httpClient.patch('api/apps/calendar/event', {\n        id,\n        event\n      }).pipe(map(updatedEvent => {\n        // Find the index of the updated event\n        const index = events.findIndex(item => item.id === id);\n        // Update the event\n        events[index] = updatedEvent;\n        // Update the events\n        this._events.next(events);\n        // Return the updated event\n        return updatedEvent;\n      }))));\n    }\n    /**\r\n     * Update recurring event\r\n     *\r\n     * @param event\r\n     * @param originalEvent\r\n     * @param mode\r\n     */\n    updateRecurringEvent(event, originalEvent, mode) {\n      return this._httpClient.patch('api/apps/calendar/recurring-event', {\n        event,\n        originalEvent,\n        mode\n      });\n    }\n    /**\r\n     * Delete event\r\n     *\r\n     * @param id\r\n     */\n    deleteEvent(id) {\n      return this.events$.pipe(take(1), switchMap(events => this._httpClient.delete('api/apps/calendar/event', {\n        params: {\n          id\n        }\n      }).pipe(map(isDeleted => {\n        // Find the index of the deleted event\n        const index = events.findIndex(item => item.id === id);\n        // Delete the event\n        events.splice(index, 1);\n        // Update the events\n        this._events.next(events);\n        // Return the deleted status\n        return isDeleted;\n      }))));\n    }\n    /**\r\n     * Delete recurring event\r\n     *\r\n     * @param event\r\n     * @param mode\r\n     */\n    deleteRecurringEvent(event, mode) {\n      return this._httpClient.delete('api/apps/calendar/recurring-event', {\n        params: {\n          event: JSON.stringify(event),\n          mode\n        }\n      });\n    }\n    /**\r\n     * Get settings\r\n     */\n    getSettings() {\n      return this._httpClient.get('api/apps/calendar/settings').pipe(tap(response => {\n        this._settings.next(response);\n      }));\n    }\n    /**\r\n     * Update settings\r\n     */\n    updateSettings(settings) {\n      return this.events$.pipe(take(1), switchMap(events => this._httpClient.patch('api/apps/calendar/settings', {\n        settings\n      }).pipe(map(updatedSettings => {\n        // Update the settings\n        this._settings.next(settings);\n        // Get weekdays again to get them in correct order\n        // in case the startWeekOn setting changes\n        this.getWeekdays().subscribe();\n        // Return the updated settings\n        return updatedSettings;\n      }))));\n    }\n    /**\r\n     * Get weekdays\r\n     */\n    getWeekdays() {\n      return this._httpClient.get('api/apps/calendar/weekdays').pipe(tap(response => {\n        this._weekdays.next(response);\n      }));\n    }\n  }\n  CalendarService.ɵfac = function CalendarService_Factory(t) {\n    return new (t || CalendarService)(i0.ɵɵinject(i1.HttpClient));\n  };\n  CalendarService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CalendarService,\n    factory: CalendarService.ɵfac,\n    providedIn: 'root'\n  });\n  return CalendarService;\n})();","map":null,"metadata":{},"sourceType":"module"}