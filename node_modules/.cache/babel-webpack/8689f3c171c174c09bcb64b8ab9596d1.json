{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport { animate, style } from '@angular/animations';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/animations\";\nimport * as i2 from \"@fuse/components/drawer/drawer.service\";\nimport * as i3 from \"@fuse/services/utils/utils.service\";\nconst _c0 = [\"*\"];\nexport let FuseDrawerComponent = /*#__PURE__*/(() => {\n  class FuseDrawerComponent {\n    /**\r\n     * Constructor\r\n     */\n    constructor(_animationBuilder, _elementRef, _renderer2, _fuseDrawerService, _fuseUtilsService) {\n      this._animationBuilder = _animationBuilder;\n      this._elementRef = _elementRef;\n      this._renderer2 = _renderer2;\n      this._fuseDrawerService = _fuseDrawerService;\n      this._fuseUtilsService = _fuseUtilsService;\n      /* eslint-enable @typescript-eslint/naming-convention */\n      this.fixed = false;\n      this.mode = 'side';\n      this.name = this._fuseUtilsService.randomId();\n      this.opened = false;\n      this.position = 'left';\n      this.transparentOverlay = false;\n      this.fixedChanged = new EventEmitter();\n      this.modeChanged = new EventEmitter();\n      this.openedChanged = new EventEmitter();\n      this.positionChanged = new EventEmitter();\n      this._animationsEnabled = false;\n      this._hovered = false;\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Host binding for component classes\r\n     */\n    get classList() {\n      return {\n        'fuse-drawer-animations-enabled': this._animationsEnabled,\n        'fuse-drawer-fixed': this.fixed,\n        'fuse-drawer-hover': this._hovered,\n        [`fuse-drawer-mode-${this.mode}`]: true,\n        'fuse-drawer-opened': this.opened,\n        [`fuse-drawer-position-${this.position}`]: true\n      };\n    }\n    /**\r\n     * Host binding for component inline styles\r\n     */\n    get styleList() {\n      return {\n        'visibility': this.opened ? 'visible' : 'hidden'\n      };\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Decorated methods\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * On mouseenter\r\n     *\r\n     * @private\r\n     */\n    _onMouseenter() {\n      // Enable the animations\n      this._enableAnimations();\n      // Set the hovered\n      this._hovered = true;\n    }\n    /**\r\n     * On mouseleave\r\n     *\r\n     * @private\r\n     */\n    _onMouseleave() {\n      // Enable the animations\n      this._enableAnimations();\n      // Set the hovered\n      this._hovered = false;\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Lifecycle hooks\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * On changes\r\n     *\r\n     * @param changes\r\n     */\n    ngOnChanges(changes) {\n      // Fixed\n      if ('fixed' in changes) {\n        // Coerce the value to a boolean\n        this.fixed = coerceBooleanProperty(changes.fixed.currentValue);\n        // Execute the observable\n        this.fixedChanged.next(this.fixed);\n      }\n      // Mode\n      if ('mode' in changes) {\n        // Get the previous and current values\n        const previousMode = changes.mode.previousValue;\n        const currentMode = changes.mode.currentValue;\n        // Disable the animations\n        this._disableAnimations();\n        // If the mode changes: 'over -> side'\n        if (previousMode === 'over' && currentMode === 'side') {\n          // Hide the overlay\n          this._hideOverlay();\n        }\n        // If the mode changes: 'side -> over'\n        if (previousMode === 'side' && currentMode === 'over') {\n          // If the drawer is opened\n          if (this.opened) {\n            // Show the overlay\n            this._showOverlay();\n          }\n        }\n        // Execute the observable\n        this.modeChanged.next(currentMode);\n        // Enable the animations after a delay\n        // The delay must be bigger than the current transition-duration\n        // to make sure nothing will be animated while the mode is changing\n        setTimeout(() => {\n          this._enableAnimations();\n        }, 500);\n      }\n      // Opened\n      if ('opened' in changes) {\n        // Coerce the value to a boolean\n        const open = coerceBooleanProperty(changes.opened.currentValue);\n        // Open/close the drawer\n        this._toggleOpened(open);\n      }\n      // Position\n      if ('position' in changes) {\n        // Execute the observable\n        this.positionChanged.next(this.position);\n      }\n      // Transparent overlay\n      if ('transparentOverlay' in changes) {\n        // Coerce the value to a boolean\n        this.transparentOverlay = coerceBooleanProperty(changes.transparentOverlay.currentValue);\n      }\n    }\n    /**\r\n     * On init\r\n     */\n    ngOnInit() {\n      // Register the drawer\n      this._fuseDrawerService.registerComponent(this.name, this);\n    }\n    /**\r\n     * On destroy\r\n     */\n    ngOnDestroy() {\n      // Finish the animation\n      if (this._player) {\n        this._player.finish();\n      }\n      // Deregister the drawer from the registry\n      this._fuseDrawerService.deregisterComponent(this.name);\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Open the drawer\r\n     */\n    open() {\n      // Return if the drawer has already opened\n      if (this.opened) {\n        return;\n      }\n      // Open the drawer\n      this._toggleOpened(true);\n    }\n    /**\r\n     * Close the drawer\r\n     */\n    close() {\n      // Return if the drawer has already closed\n      if (!this.opened) {\n        return;\n      }\n      // Close the drawer\n      this._toggleOpened(false);\n    }\n    /**\r\n     * Toggle the drawer\r\n     */\n    toggle() {\n      if (this.opened) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n    /**\r\n     * Enable the animations\r\n     *\r\n     * @private\r\n     */\n    _enableAnimations() {\n      // Return if the animations are already enabled\n      if (this._animationsEnabled) {\n        return;\n      }\n      // Enable the animations\n      this._animationsEnabled = true;\n    }\n    /**\r\n     * Disable the animations\r\n     *\r\n     * @private\r\n     */\n    _disableAnimations() {\n      // Return if the animations are already disabled\n      if (!this._animationsEnabled) {\n        return;\n      }\n      // Disable the animations\n      this._animationsEnabled = false;\n    }\n    /**\r\n     * Show the backdrop\r\n     *\r\n     * @private\r\n     */\n    _showOverlay() {\n      // Create the backdrop element\n      this._overlay = this._renderer2.createElement('div');\n      // Return if overlay couldn't be create for some reason\n      if (!this._overlay) {\n        return;\n      }\n      // Add a class to the backdrop element\n      this._overlay.classList.add('fuse-drawer-overlay');\n      // Add a class depending on the fixed option\n      if (this.fixed) {\n        this._overlay.classList.add('fuse-drawer-overlay-fixed');\n      }\n      // Add a class depending on the transparentOverlay option\n      if (this.transparentOverlay) {\n        this._overlay.classList.add('fuse-drawer-overlay-transparent');\n      }\n      // Append the backdrop to the parent of the drawer\n      this._renderer2.appendChild(this._elementRef.nativeElement.parentElement, this._overlay);\n      // Create the enter animation and attach it to the player\n      this._player = this._animationBuilder.build([style({\n        opacity: 0\n      }), animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', style({\n        opacity: 1\n      }))]).create(this._overlay);\n      // Once the animation is done...\n      this._player.onDone(() => {\n        // Destroy the player\n        this._player.destroy();\n        this._player = null;\n      });\n      // Play the animation\n      this._player.play();\n      // Add an event listener to the overlay\n      this._overlay.addEventListener('click', () => {\n        this.close();\n      });\n    }\n    /**\r\n     * Hide the backdrop\r\n     *\r\n     * @private\r\n     */\n    _hideOverlay() {\n      if (!this._overlay) {\n        return;\n      }\n      // Create the leave animation and attach it to the player\n      this._player = this._animationBuilder.build([animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', style({\n        opacity: 0\n      }))]).create(this._overlay);\n      // Play the animation\n      this._player.play();\n      // Once the animation is done...\n      this._player.onDone(() => {\n        // Destroy the player\n        this._player.destroy();\n        this._player = null;\n        // If the backdrop still exists...\n        if (this._overlay) {\n          // Remove the backdrop\n          this._overlay.parentNode.removeChild(this._overlay);\n          this._overlay = null;\n        }\n      });\n    }\n    /**\r\n     * Open/close the drawer\r\n     *\r\n     * @param open\r\n     * @private\r\n     */\n    _toggleOpened(open) {\n      // Set the opened\n      this.opened = open;\n      // Enable the animations\n      this._enableAnimations();\n      // If the mode is 'over'\n      if (this.mode === 'over') {\n        // If the drawer opens, show the overlay\n        if (open) {\n          this._showOverlay();\n        }\n        // Otherwise, close the overlay\n        else {\n          this._hideOverlay();\n        }\n      }\n      // Execute the observable\n      this.openedChanged.next(open);\n    }\n  }\n  FuseDrawerComponent.ɵfac = function FuseDrawerComponent_Factory(t) {\n    return new (t || FuseDrawerComponent)(i0.ɵɵdirectiveInject(i1.AnimationBuilder), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i2.FuseDrawerService), i0.ɵɵdirectiveInject(i3.FuseUtilsService));\n  };\n  FuseDrawerComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: FuseDrawerComponent,\n    selectors: [[\"fuse-drawer\"]],\n    hostVars: 4,\n    hostBindings: function FuseDrawerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mouseenter\", function FuseDrawerComponent_mouseenter_HostBindingHandler() {\n          return ctx._onMouseenter();\n        })(\"mouseleave\", function FuseDrawerComponent_mouseleave_HostBindingHandler() {\n          return ctx._onMouseleave();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleMap(ctx.styleList);\n        i0.ɵɵclassMap(ctx.classList);\n      }\n    },\n    inputs: {\n      fixed: \"fixed\",\n      mode: \"mode\",\n      name: \"name\",\n      opened: \"opened\",\n      position: \"position\",\n      transparentOverlay: \"transparentOverlay\"\n    },\n    outputs: {\n      fixedChanged: \"fixedChanged\",\n      modeChanged: \"modeChanged\",\n      openedChanged: \"openedChanged\",\n      positionChanged: \"positionChanged\"\n    },\n    exportAs: [\"fuseDrawer\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"fuse-drawer-content\"]],\n    template: function FuseDrawerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    styles: [\"fuse-drawer{position:relative;display:flex;flex-direction:column;flex:1 1 auto;width:320px;min-width:320px;max-width:320px;z-index:300;box-shadow:0 2px 8px #00000059;--tw-bg-opacity: 1;background-color:rgba(var(--fuse-bg-card-rgb),var(--tw-bg-opacity))}fuse-drawer.fuse-drawer-animations-enabled{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:visibility,margin-left,margin-right,transform,width,max-width,min-width}fuse-drawer.fuse-drawer-animations-enabled .fuse-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:width,max-width,min-width}fuse-drawer.fuse-drawer-mode-over{position:absolute;top:0;bottom:0}fuse-drawer.fuse-drawer-mode-over.fuse-drawer-fixed{position:fixed}fuse-drawer.fuse-drawer-position-left.fuse-drawer-mode-side{margin-left:-320px}fuse-drawer.fuse-drawer-position-left.fuse-drawer-mode-side.fuse-drawer-opened{margin-left:0}fuse-drawer.fuse-drawer-position-left.fuse-drawer-mode-over{left:0;transform:translate(-100%)}fuse-drawer.fuse-drawer-position-left.fuse-drawer-mode-over.fuse-drawer-opened{transform:translate(0)}fuse-drawer.fuse-drawer-position-left .fuse-drawer-content{left:0}fuse-drawer.fuse-drawer-position-right.fuse-drawer-mode-side{margin-right:-320px}fuse-drawer.fuse-drawer-position-right.fuse-drawer-mode-side.fuse-drawer-opened{margin-right:0}fuse-drawer.fuse-drawer-position-right.fuse-drawer-mode-over{right:0;transform:translate(100%)}fuse-drawer.fuse-drawer-position-right.fuse-drawer-mode-over.fuse-drawer-opened{transform:translate(0)}fuse-drawer.fuse-drawer-position-right .fuse-drawer-content{right:0}fuse-drawer .fuse-drawer-content{position:absolute;display:flex;flex:1 1 auto;top:0;bottom:0;width:100%;height:100%;overflow:hidden;--tw-bg-opacity: 1;background-color:rgba(var(--fuse-bg-card-rgb),var(--tw-bg-opacity))}.fuse-drawer-overlay{position:absolute;top:0;bottom:0;left:0;right:0;z-index:299;opacity:1;background-color:#0009}.fuse-drawer-overlay.fuse-drawer-overlay-fixed{position:fixed}.fuse-drawer-overlay.fuse-drawer-overlay-transparent{background-color:transparent}\\n\"],\n    encapsulation: 2\n  });\n  return FuseDrawerComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}