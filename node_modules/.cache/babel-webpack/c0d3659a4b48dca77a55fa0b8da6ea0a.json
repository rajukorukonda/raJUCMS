{"ast":null,"code":"/*!\nFullCalendar Day Grid Plugin v4.4.2\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\n\nimport { addWeeks, diffWeeks, DateProfileGenerator, createElement, listenBySelector, removeElement, computeRect, computeClippingRect, applyStyle, computeEventDraggable, computeEventStartResizable, computeEventEndResizable, cssToStr, htmlEscape, FgEventRenderer, appendToElement, prependToElement, htmlToElement, FillRenderer, memoizeRendering, createFormatter, addDays, DateComponent, rangeContainsMarker, getDayClasses, findElements, PositionCache, buildGotoAnchorHtml, findChildren, insertAfterElement, intersectRanges, memoize, ScrollComponent, matchCellWidths, uncompensateScroll, compensateScroll, subtractInnerElHeight, distributeHeight, undistributeHeight, View, Slicer, DayHeader, DaySeries, DayTable, createPlugin } from '@fullcalendar/core';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar DayGridDateProfileGenerator = /** @class */function (_super) {\n  __extends(DayGridDateProfileGenerator, _super);\n  function DayGridDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // Computes the date range that will be rendered.\n  DayGridDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.dateEnv;\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek;\n    // year and month views should be aligned with weeks. this is already done for week\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start);\n      // make end-of-week if not already\n      endOfWeek = dateEnv.startOfWeek(end);\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = addWeeks(endOfWeek, 1);\n      }\n    }\n    // ensure 6 weeks\n    if (this.options.monthMode && this.options.fixedWeekCount) {\n      var rowCnt = Math.ceil(\n      // could be partial weeks due to hiddenDays\n      diffWeeks(start, end));\n      end = addWeeks(end, 6 - rowCnt);\n    }\n    return {\n      start: start,\n      end: end\n    };\n  };\n  return DayGridDateProfileGenerator;\n}(DateProfileGenerator);\n\n/* A rectangular panel that is absolutely positioned over other content\n------------------------------------------------------------------------------------------------------------------------\nOptions:\n  - className (string)\n  - content (HTML string, element, or element array)\n  - parentEl\n  - top\n  - left\n  - right (the x coord of where the right edge should be. not a \"CSS\" right)\n  - autoHide (boolean)\n  - show (callback)\n  - hide (callback)\n*/\nvar Popover = /** @class */function () {\n  function Popover(options) {\n    var _this = this;\n    this.isHidden = true;\n    this.margin = 10; // the space required between the popover and the edges of the scroll container\n    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n    this.documentMousedown = function (ev) {\n      // only hide the popover if the click happened outside the popover\n      if (_this.el && !_this.el.contains(ev.target)) {\n        _this.hide();\n      }\n    };\n    this.options = options;\n  }\n  // Shows the popover on the specified position. Renders it if not already\n  Popover.prototype.show = function () {\n    if (this.isHidden) {\n      if (!this.el) {\n        this.render();\n      }\n      this.el.style.display = '';\n      this.position();\n      this.isHidden = false;\n      this.trigger('show');\n    }\n  };\n  // Hides the popover, through CSS, but does not remove it from the DOM\n  Popover.prototype.hide = function () {\n    if (!this.isHidden) {\n      this.el.style.display = 'none';\n      this.isHidden = true;\n      this.trigger('hide');\n    }\n  };\n  // Creates `this.el` and renders content inside of it\n  Popover.prototype.render = function () {\n    var _this = this;\n    var options = this.options;\n    var el = this.el = createElement('div', {\n      className: 'fc-popover ' + (options.className || ''),\n      style: {\n        top: '0',\n        left: '0'\n      }\n    });\n    if (typeof options.content === 'function') {\n      options.content(el);\n    }\n    options.parentEl.appendChild(el);\n    // when a click happens on anything inside with a 'fc-close' className, hide the popover\n    listenBySelector(el, 'click', '.fc-close', function (ev) {\n      _this.hide();\n    });\n    if (options.autoHide) {\n      document.addEventListener('mousedown', this.documentMousedown);\n    }\n  };\n  // Hides and unregisters any handlers\n  Popover.prototype.destroy = function () {\n    this.hide();\n    if (this.el) {\n      removeElement(this.el);\n      this.el = null;\n    }\n    document.removeEventListener('mousedown', this.documentMousedown);\n  };\n  // Positions the popover optimally, using the top/left/right options\n  Popover.prototype.position = function () {\n    var options = this.options;\n    var el = this.el;\n    var elDims = el.getBoundingClientRect(); // only used for width,height\n    var origin = computeRect(el.offsetParent);\n    var clippingRect = computeClippingRect(options.parentEl);\n    var top; // the \"position\" (not \"offset\") values for the popover\n    var left; //\n    // compute top and left\n    top = options.top || 0;\n    if (options.left !== undefined) {\n      left = options.left;\n    } else if (options.right !== undefined) {\n      left = options.right - elDims.width; // derive the left value from the right value\n    } else {\n      left = 0;\n    }\n    // constrain to the view port. if constrained by two edges, give precedence to top/left\n    top = Math.min(top, clippingRect.bottom - elDims.height - this.margin);\n    top = Math.max(top, clippingRect.top + this.margin);\n    left = Math.min(left, clippingRect.right - elDims.width - this.margin);\n    left = Math.max(left, clippingRect.left + this.margin);\n    applyStyle(el, {\n      top: top - origin.top,\n      left: left - origin.left\n    });\n  };\n  // Triggers a callback. Calls a function in the option hash of the same name.\n  // Arguments beyond the first `name` are forwarded on.\n  // TODO: better code reuse for this. Repeat code\n  // can kill this???\n  Popover.prototype.trigger = function (name) {\n    if (this.options[name]) {\n      this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n  return Popover;\n}();\n\n/* Event-rendering methods for the DayGrid class\n----------------------------------------------------------------------------------------------------------------------*/\n// \"Simple\" is bad a name. has nothing to do with SimpleDayGrid\nvar SimpleDayGridEventRenderer = /** @class */function (_super) {\n  __extends(SimpleDayGridEventRenderer, _super);\n  function SimpleDayGridEventRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // Builds the HTML to be used for the default element for an individual segment\n  SimpleDayGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {\n    var context = this.context;\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var eventUi = eventRange.ui;\n    var allDay = eventDef.allDay;\n    var isDraggable = computeEventDraggable(context, eventDef, eventUi);\n    var isResizableFromStart = allDay && seg.isStart && computeEventStartResizable(context, eventDef, eventUi);\n    var isResizableFromEnd = allDay && seg.isEnd && computeEventEndResizable(context, eventDef, eventUi);\n    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);\n    var skinCss = cssToStr(this.getSkinCss(eventUi));\n    var timeHtml = '';\n    var timeText;\n    var titleHtml;\n    classes.unshift('fc-day-grid-event', 'fc-h-event');\n    // Only display a timed events time if it is the starting segment\n    if (seg.isStart) {\n      timeText = this.getTimeText(eventRange);\n      if (timeText) {\n        timeHtml = '<span class=\"fc-time\">' + htmlEscape(timeText) + '</span>';\n      }\n    }\n    titleHtml = '<span class=\"fc-title\">' + (htmlEscape(eventDef.title || '') || '&nbsp;') +\n    // we always want one line of height\n    '</span>';\n    return '<a class=\"' + classes.join(' ') + '\"' + (eventDef.url ? ' href=\"' + htmlEscape(eventDef.url) + '\"' : '') + (skinCss ? ' style=\"' + skinCss + '\"' : '') + '>' + '<div class=\"fc-content\">' + (context.options.dir === 'rtl' ? titleHtml + ' ' + timeHtml :\n    // put a natural space in between\n    timeHtml + ' ' + titleHtml //\n    ) + '</div>' + (isResizableFromStart ? '<div class=\"fc-resizer fc-start-resizer\"></div>' : '') + (isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\"></div>' : '') + '</a>';\n  };\n  // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined\n  SimpleDayGridEventRenderer.prototype.computeEventTimeFormat = function () {\n    return {\n      hour: 'numeric',\n      minute: '2-digit',\n      omitZeroMinute: true,\n      meridiem: 'narrow'\n    };\n  };\n  SimpleDayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n    return false; // TODO: somehow consider the originating DayGrid's column count\n  };\n\n  return SimpleDayGridEventRenderer;\n}(FgEventRenderer);\n\n/* Event-rendering methods for the DayGrid class\n----------------------------------------------------------------------------------------------------------------------*/\nvar DayGridEventRenderer = /** @class */function (_super) {\n  __extends(DayGridEventRenderer, _super);\n  function DayGridEventRenderer(dayGrid) {\n    var _this = _super.call(this) || this;\n    _this.dayGrid = dayGrid;\n    return _this;\n  }\n  // Renders the given foreground event segments onto the grid\n  DayGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    var rowStructs = this.rowStructs = this.renderSegRows(segs);\n    // append to each row's content skeleton\n    this.dayGrid.rowEls.forEach(function (rowNode, i) {\n      rowNode.querySelector('.fc-content-skeleton > table').appendChild(rowStructs[i].tbodyEl);\n    });\n    // removes the \"more..\" events popover\n    if (!mirrorInfo) {\n      this.dayGrid.removeSegPopover();\n    }\n  };\n  // Unrenders all currently rendered foreground event segments\n  DayGridEventRenderer.prototype.detachSegs = function () {\n    var rowStructs = this.rowStructs || [];\n    var rowStruct;\n    while (rowStruct = rowStructs.pop()) {\n      removeElement(rowStruct.tbodyEl);\n    }\n    this.rowStructs = null;\n  };\n  // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n  // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n  // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n  DayGridEventRenderer.prototype.renderSegRows = function (segs) {\n    var rowStructs = [];\n    var segRows;\n    var row;\n    segRows = this.groupSegRows(segs); // group into nested arrays\n    // iterate each row of segment groupings\n    for (row = 0; row < segRows.length; row++) {\n      rowStructs.push(this.renderSegRow(row, segRows[row]));\n    }\n    return rowStructs;\n  };\n  // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n  // the segments. Returns object with a bunch of internal data about how the render was calculated.\n  // NOTE: modifies rowSegs\n  DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {\n    var isRtl = this.context.isRtl;\n    var dayGrid = this.dayGrid;\n    var colCnt = dayGrid.colCnt;\n    var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n    var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n    var tbody = document.createElement('tbody');\n    var segMatrix = []; // lookup for which segments are rendered into which level+col cells\n    var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n    var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n    var i;\n    var levelSegs;\n    var col;\n    var tr;\n    var j;\n    var seg;\n    var td;\n    // populates empty cells from the current column (`col`) to `endCol`\n    function emptyCellsUntil(endCol) {\n      while (col < endCol) {\n        // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n        td = (loneCellMatrix[i - 1] || [])[col];\n        if (td) {\n          td.rowSpan = (td.rowSpan || 1) + 1;\n        } else {\n          td = document.createElement('td');\n          tr.appendChild(td);\n        }\n        cellMatrix[i][col] = td;\n        loneCellMatrix[i][col] = td;\n        col++;\n      }\n    }\n    for (i = 0; i < levelCnt; i++) {\n      // iterate through all levels\n      levelSegs = segLevels[i];\n      col = 0;\n      tr = document.createElement('tr');\n      segMatrix.push([]);\n      cellMatrix.push([]);\n      loneCellMatrix.push([]);\n      // levelCnt might be 1 even though there are no actual levels. protect against this.\n      // this single empty row is useful for styling.\n      if (levelSegs) {\n        for (j = 0; j < levelSegs.length; j++) {\n          // iterate through segments in level\n          seg = levelSegs[j];\n          var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;\n          var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;\n          emptyCellsUntil(leftCol);\n          // create a container that occupies or more columns. append the event element.\n          td = createElement('td', {\n            className: 'fc-event-container'\n          }, seg.el);\n          if (leftCol !== rightCol) {\n            td.colSpan = rightCol - leftCol + 1;\n          } else {\n            // a single-column segment\n            loneCellMatrix[i][col] = td;\n          }\n          while (col <= rightCol) {\n            cellMatrix[i][col] = td;\n            segMatrix[i][col] = seg;\n            col++;\n          }\n          tr.appendChild(td);\n        }\n      }\n      emptyCellsUntil(colCnt); // finish off the row\n      var introHtml = dayGrid.renderProps.renderIntroHtml();\n      if (introHtml) {\n        if (isRtl) {\n          appendToElement(tr, introHtml);\n        } else {\n          prependToElement(tr, introHtml);\n        }\n      }\n      tbody.appendChild(tr);\n    }\n    return {\n      row: row,\n      tbodyEl: tbody,\n      cellMatrix: cellMatrix,\n      segMatrix: segMatrix,\n      segLevels: segLevels,\n      segs: rowSegs\n    };\n  };\n  // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n  // NOTE: modifies segs\n  DayGridEventRenderer.prototype.buildSegLevels = function (segs) {\n    var isRtl = this.context.isRtl;\n    var colCnt = this.dayGrid.colCnt;\n    var levels = [];\n    var i;\n    var seg;\n    var j;\n    // Give preference to elements with certain criteria, so they have\n    // a chance to be closer to the top.\n    segs = this.sortEventSegs(segs);\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n      for (j = 0; j < levels.length; j++) {\n        if (!isDaySegCollision(seg, levels[j])) {\n          break;\n        }\n      }\n      // `j` now holds the desired subrow index\n      seg.level = j;\n      seg.leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol; // for sorting only\n      seg.rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol // for sorting only\n      ;\n\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n    // order segments left-to-right. very important if calendar is RTL\n    for (j = 0; j < levels.length; j++) {\n      levels[j].sort(compareDaySegCols);\n    }\n    return levels;\n  };\n  // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n  DayGridEventRenderer.prototype.groupSegRows = function (segs) {\n    var segRows = [];\n    var i;\n    for (i = 0; i < this.dayGrid.rowCnt; i++) {\n      segRows.push([]);\n    }\n    for (i = 0; i < segs.length; i++) {\n      segRows[segs[i].row].push(segs[i]);\n    }\n    return segRows;\n  };\n  // Computes a default `displayEventEnd` value if one is not expliclty defined\n  DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n    return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\n  };\n\n  return DayGridEventRenderer;\n}(SimpleDayGridEventRenderer);\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\nfunction isDaySegCollision(seg, otherSegs) {\n  var i;\n  var otherSeg;\n  for (i = 0; i < otherSegs.length; i++) {\n    otherSeg = otherSegs[i];\n    if (otherSeg.firstCol <= seg.lastCol && otherSeg.lastCol >= seg.firstCol) {\n      return true;\n    }\n  }\n  return false;\n}\n// A cmp function for determining the leftmost event\nfunction compareDaySegCols(a, b) {\n  return a.leftCol - b.leftCol;\n}\nvar DayGridMirrorRenderer = /** @class */function (_super) {\n  __extends(DayGridMirrorRenderer, _super);\n  function DayGridMirrorRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DayGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    var sourceSeg = mirrorInfo.sourceSeg;\n    var rowStructs = this.rowStructs = this.renderSegRows(segs);\n    // inject each new event skeleton into each associated row\n    this.dayGrid.rowEls.forEach(function (rowNode, row) {\n      var skeletonEl = htmlToElement('<div class=\"fc-mirror-skeleton\"><table></table></div>'); // will be absolutely positioned\n      var skeletonTopEl;\n      var skeletonTop;\n      // If there is an original segment, match the top position. Otherwise, put it at the row's top level\n      if (sourceSeg && sourceSeg.row === row) {\n        skeletonTopEl = sourceSeg.el;\n      } else {\n        skeletonTopEl = rowNode.querySelector('.fc-content-skeleton tbody');\n        if (!skeletonTopEl) {\n          // when no events\n          skeletonTopEl = rowNode.querySelector('.fc-content-skeleton table');\n        }\n      }\n      skeletonTop = skeletonTopEl.getBoundingClientRect().top - rowNode.getBoundingClientRect().top; // the offsetParent origin\n      skeletonEl.style.top = skeletonTop + 'px';\n      skeletonEl.querySelector('table').appendChild(rowStructs[row].tbodyEl);\n      rowNode.appendChild(skeletonEl);\n    });\n  };\n  return DayGridMirrorRenderer;\n}(DayGridEventRenderer);\nvar EMPTY_CELL_HTML = '<td style=\"pointer-events:none\"></td>';\nvar DayGridFillRenderer = /** @class */function (_super) {\n  __extends(DayGridFillRenderer, _super);\n  function DayGridFillRenderer(dayGrid) {\n    var _this = _super.call(this) || this;\n    _this.fillSegTag = 'td'; // override the default tag name\n    _this.dayGrid = dayGrid;\n    return _this;\n  }\n  DayGridFillRenderer.prototype.renderSegs = function (type, context, segs) {\n    // don't render timed background events\n    if (type === 'bgEvent') {\n      segs = segs.filter(function (seg) {\n        return seg.eventRange.def.allDay;\n      });\n    }\n    _super.prototype.renderSegs.call(this, type, context, segs);\n  };\n  DayGridFillRenderer.prototype.attachSegs = function (type, segs) {\n    var els = [];\n    var i;\n    var seg;\n    var skeletonEl;\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      skeletonEl = this.renderFillRow(type, seg);\n      this.dayGrid.rowEls[seg.row].appendChild(skeletonEl);\n      els.push(skeletonEl);\n    }\n    return els;\n  };\n  // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n  DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {\n    var dayGrid = this.dayGrid;\n    var isRtl = this.context.isRtl;\n    var colCnt = dayGrid.colCnt;\n    var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;\n    var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;\n    var startCol = leftCol;\n    var endCol = rightCol + 1;\n    var className;\n    var skeletonEl;\n    var trEl;\n    if (type === 'businessHours') {\n      className = 'bgevent';\n    } else {\n      className = type.toLowerCase();\n    }\n    skeletonEl = htmlToElement('<div class=\"fc-' + className + '-skeleton\">' + '<table><tr></tr></table>' + '</div>');\n    trEl = skeletonEl.getElementsByTagName('tr')[0];\n    if (startCol > 0) {\n      appendToElement(trEl,\n      // will create (startCol + 1) td's\n      new Array(startCol + 1).join(EMPTY_CELL_HTML));\n    }\n    seg.el.colSpan = endCol - startCol;\n    trEl.appendChild(seg.el);\n    if (endCol < colCnt) {\n      appendToElement(trEl,\n      // will create (colCnt - endCol) td's\n      new Array(colCnt - endCol + 1).join(EMPTY_CELL_HTML));\n    }\n    var introHtml = dayGrid.renderProps.renderIntroHtml();\n    if (introHtml) {\n      if (isRtl) {\n        appendToElement(trEl, introHtml);\n      } else {\n        prependToElement(trEl, introHtml);\n      }\n    }\n    return skeletonEl;\n  };\n  return DayGridFillRenderer;\n}(FillRenderer);\nvar DayTile = /** @class */function (_super) {\n  __extends(DayTile, _super);\n  function DayTile(el) {\n    var _this = _super.call(this, el) || this;\n    var eventRenderer = _this.eventRenderer = new DayTileEventRenderer(_this);\n    var renderFrame = _this.renderFrame = memoizeRendering(_this._renderFrame);\n    _this.renderFgEvents = memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderFrame]);\n    _this.renderEventSelection = memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n    _this.renderEventDrag = memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);\n    _this.renderEventResize = memoizeRendering(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);\n    return _this;\n  }\n  DayTile.prototype.firstContext = function (context) {\n    context.calendar.registerInteractiveComponent(this, {\n      el: this.el,\n      useEventCenter: false\n    });\n  };\n  DayTile.prototype.render = function (props, context) {\n    this.renderFrame(props.date);\n    this.renderFgEvents(context, props.fgSegs);\n    this.renderEventSelection(props.eventSelection);\n    this.renderEventDrag(props.eventDragInstances);\n    this.renderEventResize(props.eventResizeInstances);\n  };\n  DayTile.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.renderFrame.unrender(); // should unrender everything else\n    this.context.calendar.unregisterInteractiveComponent(this);\n  };\n  DayTile.prototype._renderFrame = function (date) {\n    var _a = this.context,\n      theme = _a.theme,\n      dateEnv = _a.dateEnv,\n      options = _a.options;\n    var title = dateEnv.format(date, createFormatter(options.dayPopoverFormat) // TODO: cache\n    );\n\n    this.el.innerHTML = '<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' + '<span class=\"fc-title\">' + htmlEscape(title) + '</span>' + '<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' + '</div>' + '<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' + '<div class=\"fc-event-container\"></div>' + '</div>';\n    this.segContainerEl = this.el.querySelector('.fc-event-container');\n  };\n  DayTile.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var date = this.props.date; // HACK\n    if (positionLeft < elWidth && positionTop < elHeight) {\n      return {\n        component: this,\n        dateSpan: {\n          allDay: true,\n          range: {\n            start: date,\n            end: addDays(date, 1)\n          }\n        },\n        dayEl: this.el,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1\n      };\n    }\n  };\n  return DayTile;\n}(DateComponent);\nvar DayTileEventRenderer = /** @class */function (_super) {\n  __extends(DayTileEventRenderer, _super);\n  function DayTileEventRenderer(dayTile) {\n    var _this = _super.call(this) || this;\n    _this.dayTile = dayTile;\n    return _this;\n  }\n  DayTileEventRenderer.prototype.attachSegs = function (segs) {\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      this.dayTile.segContainerEl.appendChild(seg.el);\n    }\n  };\n  DayTileEventRenderer.prototype.detachSegs = function (segs) {\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      removeElement(seg.el);\n    }\n  };\n  return DayTileEventRenderer;\n}(SimpleDayGridEventRenderer);\nvar DayBgRow = /** @class */function () {\n  function DayBgRow(context) {\n    this.context = context;\n  }\n  DayBgRow.prototype.renderHtml = function (props) {\n    var parts = [];\n    if (props.renderIntroHtml) {\n      parts.push(props.renderIntroHtml());\n    }\n    for (var _i = 0, _a = props.cells; _i < _a.length; _i++) {\n      var cell = _a[_i];\n      parts.push(renderCellHtml(cell.date, props.dateProfile, this.context, cell.htmlAttrs));\n    }\n    if (!props.cells.length) {\n      parts.push('<td class=\"fc-day ' + this.context.theme.getClass('widgetContent') + '\"></td>');\n    }\n    if (this.context.options.dir === 'rtl') {\n      parts.reverse();\n    }\n    return '<tr>' + parts.join('') + '</tr>';\n  };\n  return DayBgRow;\n}();\nfunction renderCellHtml(date, dateProfile, context, otherAttrs) {\n  var dateEnv = context.dateEnv,\n    theme = context.theme;\n  var isDateValid = rangeContainsMarker(dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.\n  var classes = getDayClasses(date, dateProfile, context);\n  classes.unshift('fc-day', theme.getClass('widgetContent'));\n  return '<td class=\"' + classes.join(' ') + '\"' + (isDateValid ? ' data-date=\"' + dateEnv.formatIso(date, {\n    omitTime: true\n  }) + '\"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '></td>';\n}\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\nvar WEEK_NUM_FORMAT = createFormatter({\n  week: 'numeric'\n});\nvar DayGrid = /** @class */function (_super) {\n  __extends(DayGrid, _super);\n  function DayGrid(el, renderProps) {\n    var _this = _super.call(this, el) || this;\n    _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid\n    _this.isCellSizesDirty = false;\n    _this.renderProps = renderProps;\n    var eventRenderer = _this.eventRenderer = new DayGridEventRenderer(_this);\n    var fillRenderer = _this.fillRenderer = new DayGridFillRenderer(_this);\n    _this.mirrorRenderer = new DayGridMirrorRenderer(_this);\n    var renderCells = _this.renderCells = memoizeRendering(_this._renderCells, _this._unrenderCells);\n    _this.renderBusinessHours = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderCells]);\n    _this.renderDateSelection = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'), [renderCells]);\n    _this.renderBgEvents = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderCells]);\n    _this.renderFgEvents = memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderCells]);\n    _this.renderEventSelection = memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n    _this.renderEventDrag = memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderCells]);\n    _this.renderEventResize = memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderCells]);\n    return _this;\n  }\n  DayGrid.prototype.render = function (props, context) {\n    var cells = props.cells;\n    this.rowCnt = cells.length;\n    this.colCnt = cells[0].length;\n    this.renderCells(cells, props.isRigid);\n    this.renderBusinessHours(context, props.businessHourSegs);\n    this.renderDateSelection(context, props.dateSelectionSegs);\n    this.renderBgEvents(context, props.bgEventSegs);\n    this.renderFgEvents(context, props.fgEventSegs);\n    this.renderEventSelection(props.eventSelection);\n    this.renderEventDrag(props.eventDrag);\n    this.renderEventResize(props.eventResize);\n    if (this.segPopoverTile) {\n      this.updateSegPopoverTile();\n    }\n  };\n  DayGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.renderCells.unrender(); // will unrender everything else\n  };\n\n  DayGrid.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = addDays(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n  DayGrid.prototype.updateSegPopoverTile = function (date, segs) {\n    var ownProps = this.props;\n    this.segPopoverTile.receiveProps({\n      date: date || this.segPopoverTile.props.date,\n      fgSegs: segs || this.segPopoverTile.props.fgSegs,\n      eventSelection: ownProps.eventSelection,\n      eventDragInstances: ownProps.eventDrag ? ownProps.eventDrag.affectedInstances : null,\n      eventResizeInstances: ownProps.eventResize ? ownProps.eventResize.affectedInstances : null\n    }, this.context);\n  };\n  /* Date Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype._renderCells = function (cells, isRigid) {\n    var _a = this.context,\n      calendar = _a.calendar,\n      view = _a.view,\n      isRtl = _a.isRtl,\n      dateEnv = _a.dateEnv;\n    var _b = this,\n      rowCnt = _b.rowCnt,\n      colCnt = _b.colCnt;\n    var html = '';\n    var row;\n    var col;\n    for (row = 0; row < rowCnt; row++) {\n      html += this.renderDayRowHtml(row, isRigid);\n    }\n    this.el.innerHTML = html;\n    this.rowEls = findElements(this.el, '.fc-row');\n    this.cellEls = findElements(this.el, '.fc-day, .fc-disabled-day');\n    if (isRtl) {\n      this.cellEls.reverse();\n    }\n    this.rowPositions = new PositionCache(this.el, this.rowEls, false, true // vertical\n    );\n\n    this.colPositions = new PositionCache(this.el, this.cellEls.slice(0, colCnt),\n    // only the first row\n    true, false // horizontal\n    );\n    // trigger dayRender with each cell's element\n    for (row = 0; row < rowCnt; row++) {\n      for (col = 0; col < colCnt; col++) {\n        calendar.publiclyTrigger('dayRender', [{\n          date: dateEnv.toDate(cells[row][col].date),\n          el: this.getCellEl(row, col),\n          view: view\n        }]);\n      }\n    }\n    this.isCellSizesDirty = true;\n  };\n  DayGrid.prototype._unrenderCells = function () {\n    this.removeSegPopover();\n  };\n  // Generates the HTML for a single row, which is a div that wraps a table.\n  // `row` is the row number.\n  DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {\n    var theme = this.context.theme;\n    var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];\n    if (isRigid) {\n      classes.push('fc-rigid');\n    }\n    var bgRow = new DayBgRow(this.context);\n    return '' + '<div class=\"' + classes.join(' ') + '\">' + '<div class=\"fc-bg\">' + '<table class=\"' + theme.getClass('tableGrid') + '\">' + bgRow.renderHtml({\n      cells: this.props.cells[row],\n      dateProfile: this.props.dateProfile,\n      renderIntroHtml: this.renderProps.renderBgIntroHtml\n    }) + '</table>' + '</div>' + '<div class=\"fc-content-skeleton\">' + '<table>' + (this.getIsNumbersVisible() ? '<thead>' + this.renderNumberTrHtml(row) + '</thead>' : '') + '</table>' + '</div>' + '</div>';\n  };\n  DayGrid.prototype.getIsNumbersVisible = function () {\n    return this.getIsDayNumbersVisible() || this.renderProps.cellWeekNumbersVisible || this.renderProps.colWeekNumbersVisible;\n  };\n  DayGrid.prototype.getIsDayNumbersVisible = function () {\n    return this.rowCnt > 1;\n  };\n  /* Grid Number Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype.renderNumberTrHtml = function (row) {\n    var isRtl = this.context.isRtl;\n    var intro = this.renderProps.renderNumberIntroHtml(row, this);\n    return '' + '<tr>' + (isRtl ? '' : intro) + this.renderNumberCellsHtml(row) + (isRtl ? intro : '') + '</tr>';\n  };\n  DayGrid.prototype.renderNumberCellsHtml = function (row) {\n    var htmls = [];\n    var col;\n    var date;\n    for (col = 0; col < this.colCnt; col++) {\n      date = this.props.cells[row][col].date;\n      htmls.push(this.renderNumberCellHtml(date));\n    }\n    if (this.context.isRtl) {\n      htmls.reverse();\n    }\n    return htmls.join('');\n  };\n  // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n  // The number row will only exist if either day numbers or week numbers are turned on.\n  DayGrid.prototype.renderNumberCellHtml = function (date) {\n    var _a = this.context,\n      dateEnv = _a.dateEnv,\n      options = _a.options;\n    var html = '';\n    var isDateValid = rangeContainsMarker(this.props.dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.\n    var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\n    var classes;\n    var weekCalcFirstDow;\n    if (!isDayNumberVisible && !this.renderProps.cellWeekNumbersVisible) {\n      // no numbers in day cell (week number must be along the side)\n      return '<td></td>'; //  will create an empty space above events :(\n    }\n\n    classes = getDayClasses(date, this.props.dateProfile, this.context);\n    classes.unshift('fc-day-top');\n    if (this.renderProps.cellWeekNumbersVisible) {\n      weekCalcFirstDow = dateEnv.weekDow;\n    }\n    html += '<td class=\"' + classes.join(' ') + '\"' + (isDateValid ? ' data-date=\"' + dateEnv.formatIso(date, {\n      omitTime: true\n    }) + '\"' : '') + '>';\n    if (this.renderProps.cellWeekNumbersVisible && date.getUTCDay() === weekCalcFirstDow) {\n      html += buildGotoAnchorHtml(options, dateEnv, {\n        date: date,\n        type: 'week'\n      }, {\n        'class': 'fc-week-number'\n      }, dateEnv.format(date, WEEK_NUM_FORMAT) // inner HTML\n      );\n    }\n\n    if (isDayNumberVisible) {\n      html += buildGotoAnchorHtml(options, dateEnv, date, {\n        'class': 'fc-day-number'\n      }, dateEnv.format(date, DAY_NUM_FORMAT) // inner HTML\n      );\n    }\n\n    html += '</td>';\n    return html;\n  };\n  /* Sizing\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype.updateSize = function (isResize) {\n    var calendar = this.context.calendar;\n    var _a = this,\n      fillRenderer = _a.fillRenderer,\n      eventRenderer = _a.eventRenderer,\n      mirrorRenderer = _a.mirrorRenderer;\n    if (isResize || this.isCellSizesDirty || calendar.isEventsUpdated // hack\n    ) {\n      this.buildPositionCaches();\n      this.isCellSizesDirty = false;\n    }\n    fillRenderer.computeSizes(isResize);\n    eventRenderer.computeSizes(isResize);\n    mirrorRenderer.computeSizes(isResize);\n    fillRenderer.assignSizes(isResize);\n    eventRenderer.assignSizes(isResize);\n    mirrorRenderer.assignSizes(isResize);\n  };\n  DayGrid.prototype.buildPositionCaches = function () {\n    this.buildColPositions();\n    this.buildRowPositions();\n  };\n  DayGrid.prototype.buildColPositions = function () {\n    this.colPositions.build();\n  };\n  DayGrid.prototype.buildRowPositions = function () {\n    this.rowPositions.build();\n    this.rowPositions.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n  };\n  /* Hit System\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype.positionToHit = function (leftPosition, topPosition) {\n    var _a = this,\n      colPositions = _a.colPositions,\n      rowPositions = _a.rowPositions;\n    var col = colPositions.leftToIndex(leftPosition);\n    var row = rowPositions.topToIndex(topPosition);\n    if (row != null && col != null) {\n      return {\n        row: row,\n        col: col,\n        dateSpan: {\n          range: this.getCellRange(row, col),\n          allDay: true\n        },\n        dayEl: this.getCellEl(row, col),\n        relativeRect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        }\n      };\n    }\n  };\n  /* Cell System\n  ------------------------------------------------------------------------------------------------------------------*/\n  // FYI: the first column is the leftmost column, regardless of date\n  DayGrid.prototype.getCellEl = function (row, col) {\n    return this.cellEls[row * this.colCnt + col];\n  };\n  /* Event Drag Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype._renderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      this.fillRenderer.renderSegs('highlight', this.context, state.segs);\n    }\n  };\n  DayGrid.prototype._unrenderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.fillRenderer.unrender('highlight', this.context);\n    }\n  };\n  /* Event Resize Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype._renderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      this.fillRenderer.renderSegs('highlight', this.context, state.segs);\n      this.mirrorRenderer.renderSegs(this.context, state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n  DayGrid.prototype._unrenderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.fillRenderer.unrender('highlight', this.context);\n      this.mirrorRenderer.unrender(this.context, state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n  /* More+ Link Popover\n  ------------------------------------------------------------------------------------------------------------------*/\n  DayGrid.prototype.removeSegPopover = function () {\n    if (this.segPopover) {\n      this.segPopover.hide(); // in handler, will call segPopover's removeElement\n    }\n  };\n  // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n  // `levelLimit` can be false (don't limit), a number, or true (should be computed).\n  DayGrid.prototype.limitRows = function (levelLimit) {\n    var rowStructs = this.eventRenderer.rowStructs || [];\n    var row; // row #\n    var rowLevelLimit;\n    for (row = 0; row < rowStructs.length; row++) {\n      this.unlimitRow(row);\n      if (!levelLimit) {\n        rowLevelLimit = false;\n      } else if (typeof levelLimit === 'number') {\n        rowLevelLimit = levelLimit;\n      } else {\n        rowLevelLimit = this.computeRowLevelLimit(row);\n      }\n      if (rowLevelLimit !== false) {\n        this.limitRow(row, rowLevelLimit);\n      }\n    }\n  };\n  // Computes the number of levels a row will accomodate without going outside its bounds.\n  // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n  // `row` is the row number.\n  DayGrid.prototype.computeRowLevelLimit = function (row) {\n    var rowEl = this.rowEls[row]; // the containing \"fake\" row div\n    var rowBottom = rowEl.getBoundingClientRect().bottom; // relative to viewport!\n    var trEls = findChildren(this.eventRenderer.rowStructs[row].tbodyEl);\n    var i;\n    var trEl;\n    // Reveal one level <tr> at a time and stop when we find one out of bounds\n    for (i = 0; i < trEls.length; i++) {\n      trEl = trEls[i];\n      trEl.classList.remove('fc-limited'); // reset to original state (reveal)\n      if (trEl.getBoundingClientRect().bottom > rowBottom) {\n        return i;\n      }\n    }\n    return false; // should not limit at all\n  };\n  // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n  // `row` is the row number.\n  // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n  DayGrid.prototype.limitRow = function (row, levelLimit) {\n    var _this = this;\n    var colCnt = this.colCnt;\n    var isRtl = this.context.isRtl;\n    var rowStruct = this.eventRenderer.rowStructs[row];\n    var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n    var col = 0; // col #, left-to-right (not chronologically)\n    var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n    var cellMatrix; // a matrix (by level, then column) of all <td> elements in the row\n    var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n    var i;\n    var seg;\n    var segsBelow; // array of segment objects below `seg` in the current `col`\n    var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n    var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n    var td;\n    var rowSpan;\n    var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n    var j;\n    var moreTd;\n    var moreWrap;\n    var moreLink;\n    // Iterates through empty level cells and places \"more\" links inside if need be\n    var emptyCellsUntil = function (endCol) {\n      while (col < endCol) {\n        segsBelow = _this.getCellSegs(row, col, levelLimit);\n        if (segsBelow.length) {\n          td = cellMatrix[levelLimit - 1][col];\n          moreLink = _this.renderMoreLink(row, col, segsBelow);\n          moreWrap = createElement('div', null, moreLink);\n          td.appendChild(moreWrap);\n          moreNodes.push(moreWrap);\n        }\n        col++;\n      }\n    };\n    if (levelLimit && levelLimit < rowStruct.segLevels.length) {\n      // is it actually over the limit?\n      levelSegs = rowStruct.segLevels[levelLimit - 1];\n      cellMatrix = rowStruct.cellMatrix;\n      limitedNodes = findChildren(rowStruct.tbodyEl).slice(levelLimit); // get level <tr> elements past the limit\n      limitedNodes.forEach(function (node) {\n        node.classList.add('fc-limited'); // hide elements and get a simple DOM-nodes array\n      });\n      // iterate though segments in the last allowable level\n      for (i = 0; i < levelSegs.length; i++) {\n        seg = levelSegs[i];\n        var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;\n        var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;\n        emptyCellsUntil(leftCol); // process empty cells before the segment\n        // determine *all* segments below `seg` that occupy the same columns\n        colSegsBelow = [];\n        totalSegsBelow = 0;\n        while (col <= rightCol) {\n          segsBelow = this.getCellSegs(row, col, levelLimit);\n          colSegsBelow.push(segsBelow);\n          totalSegsBelow += segsBelow.length;\n          col++;\n        }\n        if (totalSegsBelow) {\n          // do we need to replace this segment with one or many \"more\" links?\n          td = cellMatrix[levelLimit - 1][leftCol]; // the segment's parent cell\n          rowSpan = td.rowSpan || 1;\n          segMoreNodes = [];\n          // make a replacement <td> for each column the segment occupies. will be one for each colspan\n          for (j = 0; j < colSegsBelow.length; j++) {\n            moreTd = createElement('td', {\n              className: 'fc-more-cell',\n              rowSpan: rowSpan\n            });\n            segsBelow = colSegsBelow[j];\n            moreLink = this.renderMoreLink(row, leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\n            );\n\n            moreWrap = createElement('div', null, moreLink);\n            moreTd.appendChild(moreWrap);\n            segMoreNodes.push(moreTd);\n            moreNodes.push(moreTd);\n          }\n          td.classList.add('fc-limited');\n          insertAfterElement(td, segMoreNodes);\n          limitedNodes.push(td);\n        }\n      }\n      emptyCellsUntil(this.colCnt); // finish off the level\n      rowStruct.moreEls = moreNodes; // for easy undoing later\n      rowStruct.limitedEls = limitedNodes; // for easy undoing later\n    }\n  };\n  // Reveals all levels and removes all \"more\"-related elements for a grid's row.\n  // `row` is a row number.\n  DayGrid.prototype.unlimitRow = function (row) {\n    var rowStruct = this.eventRenderer.rowStructs[row];\n    if (rowStruct.moreEls) {\n      rowStruct.moreEls.forEach(removeElement);\n      rowStruct.moreEls = null;\n    }\n    if (rowStruct.limitedEls) {\n      rowStruct.limitedEls.forEach(function (limitedEl) {\n        limitedEl.classList.remove('fc-limited');\n      });\n      rowStruct.limitedEls = null;\n    }\n  };\n  // Renders an <a> element that represents hidden event element for a cell.\n  // Responsible for attaching click handler as well.\n  DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {\n    var _this = this;\n    var _a = this.context,\n      calendar = _a.calendar,\n      view = _a.view,\n      dateEnv = _a.dateEnv,\n      options = _a.options,\n      isRtl = _a.isRtl;\n    var a = createElement('a', {\n      className: 'fc-more'\n    });\n    a.innerText = this.getMoreLinkText(hiddenSegs.length);\n    a.addEventListener('click', function (ev) {\n      var clickOption = options.eventLimitClick;\n      var _col = isRtl ? _this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?\n      var date = _this.props.cells[row][_col].date;\n      var moreEl = ev.currentTarget;\n      var dayEl = _this.getCellEl(row, col);\n      var allSegs = _this.getCellSegs(row, col);\n      // rescope the segments to be within the cell's date\n      var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n      var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n      if (typeof clickOption === 'function') {\n        // the returned value can be an atomic option\n        clickOption = calendar.publiclyTrigger('eventLimitClick', [{\n          date: dateEnv.toDate(date),\n          allDay: true,\n          dayEl: dayEl,\n          moreEl: moreEl,\n          segs: reslicedAllSegs,\n          hiddenSegs: reslicedHiddenSegs,\n          jsEvent: ev,\n          view: view\n        }]);\n      }\n      if (clickOption === 'popover') {\n        _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n      } else if (typeof clickOption === 'string') {\n        // a view name\n        calendar.zoomTo(date, clickOption);\n      }\n    });\n    return a;\n  };\n  // Reveals the popover that displays all events within a cell\n  DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {\n    var _this = this;\n    var _a = this.context,\n      calendar = _a.calendar,\n      view = _a.view,\n      theme = _a.theme,\n      isRtl = _a.isRtl;\n    var _col = isRtl ? this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?\n    var moreWrap = moreLink.parentNode; // the <div> wrapper around the <a>\n    var topEl; // the element we want to match the top coordinate of\n    var options;\n    if (this.rowCnt === 1) {\n      topEl = view.el; // will cause the popover to cover any sort of header\n    } else {\n      topEl = this.rowEls[row]; // will align with top of row\n    }\n\n    options = {\n      className: 'fc-more-popover ' + theme.getClass('popover'),\n      parentEl: view.el,\n      top: computeRect(topEl).top,\n      autoHide: true,\n      content: function (el) {\n        _this.segPopoverTile = new DayTile(el);\n        _this.updateSegPopoverTile(_this.props.cells[row][_col].date, segs);\n      },\n      hide: function () {\n        _this.segPopoverTile.destroy();\n        _this.segPopoverTile = null;\n        _this.segPopover.destroy();\n        _this.segPopover = null;\n      }\n    };\n    // Determine horizontal coordinate.\n    // We use the moreWrap instead of the <td> to avoid border confusion.\n    if (isRtl) {\n      options.right = computeRect(moreWrap).right + 1; // +1 to be over cell border\n    } else {\n      options.left = computeRect(moreWrap).left - 1; // -1 to be over cell border\n    }\n\n    this.segPopover = new Popover(options);\n    this.segPopover.show();\n    calendar.releaseAfterSizingTriggers(); // hack for eventPositioned\n  };\n  // Given the events within an array of segment objects, reslice them to be in a single day\n  DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {\n    var dayStart = dayDate;\n    var dayEnd = addDays(dayStart, 1);\n    var dayRange = {\n      start: dayStart,\n      end: dayEnd\n    };\n    var newSegs = [];\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      var eventRange = seg.eventRange;\n      var origRange = eventRange.range;\n      var slicedRange = intersectRanges(origRange, dayRange);\n      if (slicedRange) {\n        newSegs.push(__assign({}, seg, {\n          eventRange: {\n            def: eventRange.def,\n            ui: __assign({}, eventRange.ui, {\n              durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n          },\n          isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n          isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n        }));\n      }\n    }\n    return newSegs;\n  };\n  // Generates the text that should be inside a \"more\" link, given the number of events it represents\n  DayGrid.prototype.getMoreLinkText = function (num) {\n    var opt = this.context.options.eventLimitText;\n    if (typeof opt === 'function') {\n      return opt(num);\n    } else {\n      return '+' + num + ' ' + opt;\n    }\n  };\n  // Returns segments within a given cell.\n  // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n  DayGrid.prototype.getCellSegs = function (row, col, startLevel) {\n    var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\n    var level = startLevel || 0;\n    var segs = [];\n    var seg;\n    while (level < segMatrix.length) {\n      seg = segMatrix[level][col];\n      if (seg) {\n        segs.push(seg);\n      }\n      level++;\n    }\n    return segs;\n  };\n  return DayGrid;\n}(DateComponent);\nvar WEEK_NUM_FORMAT$1 = createFormatter({\n  week: 'numeric'\n});\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nvar AbstractDayGridView = /** @class */function (_super) {\n  __extends(AbstractDayGridView, _super);\n  function AbstractDayGridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.processOptions = memoize(_this._processOptions);\n    _this.renderSkeleton = memoizeRendering(_this._renderSkeleton, _this._unrenderSkeleton);\n    /* Header Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that will go before the day-of week header cells\n    _this.renderHeadIntroHtml = function () {\n      var _a = _this.context,\n        theme = _a.theme,\n        options = _a.options;\n      if (_this.colWeekNumbersVisible) {\n        return '' + '<th class=\"fc-week-number ' + theme.getClass('widgetHeader') + '\" ' + _this.weekNumberStyleAttr() + '>' + '<span>' +\n        // needed for matchCellWidths\n        htmlEscape(options.weekLabel) + '</span>' + '</th>';\n      }\n      return '';\n    };\n    /* Day Grid Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n    _this.renderDayGridNumberIntroHtml = function (row, dayGrid) {\n      var _a = _this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n      var weekStart = dayGrid.props.cells[row][0].date;\n      if (_this.colWeekNumbersVisible) {\n        return '' + '<td class=\"fc-week-number\" ' + _this.weekNumberStyleAttr() + '>' + buildGotoAnchorHtml(\n        // aside from link, important for matchCellWidths\n        options, dateEnv, {\n          date: weekStart,\n          type: 'week',\n          forceOff: dayGrid.colCnt === 1\n        }, dateEnv.format(weekStart, WEEK_NUM_FORMAT$1) // inner HTML\n        ) + '</td>';\n      }\n      return '';\n    };\n    // Generates the HTML that goes before the day bg cells for each day-row\n    _this.renderDayGridBgIntroHtml = function () {\n      var theme = _this.context.theme;\n      if (_this.colWeekNumbersVisible) {\n        return '<td class=\"fc-week-number ' + theme.getClass('widgetContent') + '\" ' + _this.weekNumberStyleAttr() + '></td>';\n      }\n      return '';\n    };\n    // Generates the HTML that goes before every other type of row generated by DayGrid.\n    // Affects mirror-skeleton and highlight-skeleton rows.\n    _this.renderDayGridIntroHtml = function () {\n      if (_this.colWeekNumbersVisible) {\n        return '<td class=\"fc-week-number\" ' + _this.weekNumberStyleAttr() + '></td>';\n      }\n      return '';\n    };\n    return _this;\n  }\n  AbstractDayGridView.prototype._processOptions = function (options) {\n    if (options.weekNumbers) {\n      if (options.weekNumbersWithinDays) {\n        this.cellWeekNumbersVisible = true;\n        this.colWeekNumbersVisible = false;\n      } else {\n        this.cellWeekNumbersVisible = false;\n        this.colWeekNumbersVisible = true;\n      }\n    } else {\n      this.colWeekNumbersVisible = false;\n      this.cellWeekNumbersVisible = false;\n    }\n  };\n  AbstractDayGridView.prototype.render = function (props, context) {\n    _super.prototype.render.call(this, props, context);\n    this.processOptions(context.options);\n    this.renderSkeleton(context);\n  };\n  AbstractDayGridView.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.renderSkeleton.unrender();\n  };\n  AbstractDayGridView.prototype._renderSkeleton = function (context) {\n    this.el.classList.add('fc-dayGrid-view');\n    this.el.innerHTML = this.renderSkeletonHtml();\n    this.scroller = new ScrollComponent('hidden',\n    // overflow x\n    'auto' // overflow y\n    );\n\n    var dayGridContainerEl = this.scroller.el;\n    this.el.querySelector('.fc-body > tr > td').appendChild(dayGridContainerEl);\n    dayGridContainerEl.classList.add('fc-day-grid-container');\n    var dayGridEl = createElement('div', {\n      className: 'fc-day-grid'\n    });\n    dayGridContainerEl.appendChild(dayGridEl);\n    this.dayGrid = new DayGrid(dayGridEl, {\n      renderNumberIntroHtml: this.renderDayGridNumberIntroHtml,\n      renderBgIntroHtml: this.renderDayGridBgIntroHtml,\n      renderIntroHtml: this.renderDayGridIntroHtml,\n      colWeekNumbersVisible: this.colWeekNumbersVisible,\n      cellWeekNumbersVisible: this.cellWeekNumbersVisible\n    });\n  };\n  AbstractDayGridView.prototype._unrenderSkeleton = function () {\n    this.el.classList.remove('fc-dayGrid-view');\n    this.dayGrid.destroy();\n    this.scroller.destroy();\n  };\n  // Builds the HTML skeleton for the view.\n  // The day-grid component will render inside of a container defined by this HTML.\n  AbstractDayGridView.prototype.renderSkeletonHtml = function () {\n    var _a = this.context,\n      theme = _a.theme,\n      options = _a.options;\n    return '' + '<table class=\"' + theme.getClass('tableGrid') + '\">' + (options.columnHeader ? '<thead class=\"fc-head\">' + '<tr>' + '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class=\"fc-body\">' + '<tr>' + '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' + '</tr>' + '</tbody>' + '</table>';\n  };\n  // Generates an HTML attribute string for setting the width of the week number column, if it is known\n  AbstractDayGridView.prototype.weekNumberStyleAttr = function () {\n    if (this.weekNumberWidth != null) {\n      return 'style=\"width:' + this.weekNumberWidth + 'px\"';\n    }\n    return '';\n  };\n  // Determines whether each row should have a constant height\n  AbstractDayGridView.prototype.hasRigidRows = function () {\n    var eventLimit = this.context.options.eventLimit;\n    return eventLimit && typeof eventLimit !== 'number';\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n  AbstractDayGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {\n    _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first\n    this.dayGrid.updateSize(isResize);\n  };\n  // Refreshes the horizontal dimensions of the view\n  AbstractDayGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {\n    var dayGrid = this.dayGrid;\n    var eventLimit = this.context.options.eventLimit;\n    var headRowEl = this.header ? this.header.el : null; // HACK\n    var scrollerHeight;\n    var scrollbarWidths;\n    // hack to give the view some height prior to dayGrid's columns being rendered\n    // TODO: separate setting height from scroller VS dayGrid.\n    if (!dayGrid.rowEls) {\n      if (!isAuto) {\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      }\n      return;\n    }\n    if (this.colWeekNumbersVisible) {\n      // Make sure all week number cells running down the side have the same width.\n      this.weekNumberWidth = matchCellWidths(findElements(this.el, '.fc-week-number'));\n    }\n    // reset all heights to be natural\n    this.scroller.clear();\n    if (headRowEl) {\n      uncompensateScroll(headRowEl);\n    }\n    dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n    // is the event limit a constant level number?\n    if (eventLimit && typeof eventLimit === 'number') {\n      dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n    }\n    // distribute the height to the rows\n    // (viewHeight is a \"recommended\" value if isAuto)\n    scrollerHeight = this.computeScrollerHeight(viewHeight);\n    this.setGridHeight(scrollerHeight, isAuto);\n    // is the event limit dynamically calculated?\n    if (eventLimit && typeof eventLimit !== 'number') {\n      dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n    }\n\n    if (!isAuto) {\n      // should we force dimensions of the scroll container?\n      this.scroller.setHeight(scrollerHeight);\n      scrollbarWidths = this.scroller.getScrollbarWidths();\n      if (scrollbarWidths.left || scrollbarWidths.right) {\n        // using scrollbars?\n        if (headRowEl) {\n          compensateScroll(headRowEl, scrollbarWidths);\n        }\n        // doing the scrollbar compensation might have created text overflow which created more height. redo\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      }\n      // guarantees the same scrollbar widths\n      this.scroller.lockOverflow(scrollbarWidths);\n    }\n  };\n  // given a desired total height of the view, returns what the height of the scroller should be\n  AbstractDayGridView.prototype.computeScrollerHeight = function (viewHeight) {\n    return viewHeight - subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n  };\n  // Sets the height of just the DayGrid component in this view\n  AbstractDayGridView.prototype.setGridHeight = function (height, isAuto) {\n    if (this.context.options.monthMode) {\n      // if auto, make the height of each row the height that it would be if there were 6 weeks\n      if (isAuto) {\n        height *= this.dayGrid.rowCnt / 6;\n      }\n      distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n    } else {\n      if (isAuto) {\n        undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n      } else {\n        distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n      }\n    }\n  };\n  /* Scroll\n  ------------------------------------------------------------------------------------------------------------------*/\n  AbstractDayGridView.prototype.computeDateScroll = function (duration) {\n    return {\n      top: 0\n    };\n  };\n  AbstractDayGridView.prototype.queryDateScroll = function () {\n    return {\n      top: this.scroller.getScrollTop()\n    };\n  };\n  AbstractDayGridView.prototype.applyDateScroll = function (scroll) {\n    if (scroll.top !== undefined) {\n      this.scroller.setScrollTop(scroll.top);\n    }\n  };\n  return AbstractDayGridView;\n}(View);\nAbstractDayGridView.prototype.dateProfileGeneratorClass = DayGridDateProfileGenerator;\nvar SimpleDayGrid = /** @class */function (_super) {\n  __extends(SimpleDayGrid, _super);\n  function SimpleDayGrid(dayGrid) {\n    var _this = _super.call(this, dayGrid.el) || this;\n    _this.slicer = new DayGridSlicer();\n    _this.dayGrid = dayGrid;\n    return _this;\n  }\n  SimpleDayGrid.prototype.firstContext = function (context) {\n    context.calendar.registerInteractiveComponent(this, {\n      el: this.dayGrid.el\n    });\n  };\n  SimpleDayGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.context.calendar.unregisterInteractiveComponent(this);\n  };\n  SimpleDayGrid.prototype.render = function (props, context) {\n    var dayGrid = this.dayGrid;\n    var dateProfile = props.dateProfile,\n      dayTable = props.dayTable;\n    dayGrid.receiveContext(context); // hack because context is used in sliceProps\n    dayGrid.receiveProps(__assign({}, this.slicer.sliceProps(props, dateProfile, props.nextDayThreshold, context.calendar, dayGrid, dayTable), {\n      dateProfile: dateProfile,\n      cells: dayTable.cells,\n      isRigid: props.isRigid\n    }), context);\n  };\n  SimpleDayGrid.prototype.buildPositionCaches = function () {\n    this.dayGrid.buildPositionCaches();\n  };\n  SimpleDayGrid.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.dayGrid.positionToHit(positionLeft, positionTop);\n    if (rawHit) {\n      return {\n        component: this.dayGrid,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n  };\n  return SimpleDayGrid;\n}(DateComponent);\nvar DayGridSlicer = /** @class */function (_super) {\n  __extends(DayGridSlicer, _super);\n  function DayGridSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DayGridSlicer.prototype.sliceRange = function (dateRange, dayTable) {\n    return dayTable.sliceRange(dateRange);\n  };\n  return DayGridSlicer;\n}(Slicer);\nvar DayGridView = /** @class */function (_super) {\n  __extends(DayGridView, _super);\n  function DayGridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.buildDayTable = memoize(buildDayTable);\n    return _this;\n  }\n  DayGridView.prototype.render = function (props, context) {\n    _super.prototype.render.call(this, props, context); // will call _renderSkeleton/_unrenderSkeleton\n    var dateProfile = this.props.dateProfile;\n    var dayTable = this.dayTable = this.buildDayTable(dateProfile, props.dateProfileGenerator);\n    if (this.header) {\n      this.header.receiveProps({\n        dateProfile: dateProfile,\n        dates: dayTable.headerDates,\n        datesRepDistinctDays: dayTable.rowCnt === 1,\n        renderIntroHtml: this.renderHeadIntroHtml\n      }, context);\n    }\n    this.simpleDayGrid.receiveProps({\n      dateProfile: dateProfile,\n      dayTable: dayTable,\n      businessHours: props.businessHours,\n      dateSelection: props.dateSelection,\n      eventStore: props.eventStore,\n      eventUiBases: props.eventUiBases,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isRigid: this.hasRigidRows(),\n      nextDayThreshold: this.context.nextDayThreshold\n    }, context);\n  };\n  DayGridView.prototype._renderSkeleton = function (context) {\n    _super.prototype._renderSkeleton.call(this, context);\n    if (context.options.columnHeader) {\n      this.header = new DayHeader(this.el.querySelector('.fc-head-container'));\n    }\n    this.simpleDayGrid = new SimpleDayGrid(this.dayGrid);\n  };\n  DayGridView.prototype._unrenderSkeleton = function () {\n    _super.prototype._unrenderSkeleton.call(this);\n    if (this.header) {\n      this.header.destroy();\n    }\n    this.simpleDayGrid.destroy();\n  };\n  return DayGridView;\n}(AbstractDayGridView);\nfunction buildDayTable(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeries(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTable(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nvar main = createPlugin({\n  defaultView: 'dayGridMonth',\n  views: {\n    dayGrid: DayGridView,\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\nexport default main;\nexport { AbstractDayGridView, DayBgRow, DayGrid, DayGridSlicer, DayGridView, SimpleDayGrid, buildDayTable as buildBasicDayTable };","map":null,"metadata":{},"sourceType":"module"}