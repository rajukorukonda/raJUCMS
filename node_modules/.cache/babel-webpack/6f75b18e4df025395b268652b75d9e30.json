{"ast":null,"code":"/*!\nFullCalendar Time Grid Plugin v4.4.2\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\n\nimport { createFormatter, removeElement, computeEventDraggable, computeEventStartResizable, computeEventEndResizable, cssToStr, isMultiDayRange, htmlEscape, compareByFieldSpecs, applyStyle, FgEventRenderer, buildSegCompareObj, FillRenderer, memoize, memoizeRendering, createDuration, wholeDivideDurations, findElements, PositionCache, startOfDay, asRoughMs, formatIsoTimeString, addDurations, htmlToElement, createElement, multiplyDuration, DateComponent, hasBgRendering, Splitter, diffDays, buildGotoAnchorHtml, getAllDayHtml, ScrollComponent, matchCellWidths, uncompensateScroll, compensateScroll, subtractInnerElHeight, View, intersectRanges, Slicer, DayHeader, DaySeries, DayTable, createPlugin } from '@fullcalendar/core';\nimport { DayBgRow, DayGrid, SimpleDayGrid } from '@fullcalendar/daygrid';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\n\n/*\nOnly handles foreground segs.\nDoes not own rendering. Use for low-level util methods by TimeGrid.\n*/\nvar TimeGridEventRenderer = /** @class */function (_super) {\n  __extends(TimeGridEventRenderer, _super);\n  function TimeGridEventRenderer(timeGrid) {\n    var _this = _super.call(this) || this;\n    _this.timeGrid = timeGrid;\n    return _this;\n  }\n  TimeGridEventRenderer.prototype.renderSegs = function (context, segs, mirrorInfo) {\n    _super.prototype.renderSegs.call(this, context, segs, mirrorInfo);\n    // TODO: dont do every time. memoize\n    this.fullTimeFormat = createFormatter({\n      hour: 'numeric',\n      minute: '2-digit',\n      separator: this.context.options.defaultRangeSeparator\n    });\n  };\n  // Given an array of foreground segments, render a DOM element for each, computes position,\n  // and attaches to the column inner-container elements.\n  TimeGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    var segsByCol = this.timeGrid.groupSegsByCol(segs);\n    // order the segs within each column\n    // TODO: have groupSegsByCol do this?\n    for (var col = 0; col < segsByCol.length; col++) {\n      segsByCol[col] = this.sortEventSegs(segsByCol[col]);\n    }\n    this.segsByCol = segsByCol;\n    this.timeGrid.attachSegsByCol(segsByCol, this.timeGrid.fgContainerEls);\n  };\n  TimeGridEventRenderer.prototype.detachSegs = function (segs) {\n    segs.forEach(function (seg) {\n      removeElement(seg.el);\n    });\n    this.segsByCol = null;\n  };\n  TimeGridEventRenderer.prototype.computeSegSizes = function (allSegs) {\n    var _a = this,\n      timeGrid = _a.timeGrid,\n      segsByCol = _a.segsByCol;\n    var colCnt = timeGrid.colCnt;\n    timeGrid.computeSegVerticals(allSegs); // horizontals relies on this\n    if (segsByCol) {\n      for (var col = 0; col < colCnt; col++) {\n        this.computeSegHorizontals(segsByCol[col]); // compute horizontal coordinates, z-index's, and reorder the array\n      }\n    }\n  };\n\n  TimeGridEventRenderer.prototype.assignSegSizes = function (allSegs) {\n    var _a = this,\n      timeGrid = _a.timeGrid,\n      segsByCol = _a.segsByCol;\n    var colCnt = timeGrid.colCnt;\n    timeGrid.assignSegVerticals(allSegs); // horizontals relies on this\n    if (segsByCol) {\n      for (var col = 0; col < colCnt; col++) {\n        this.assignSegCss(segsByCol[col]);\n      }\n    }\n  };\n  // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined\n  TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {\n    return {\n      hour: 'numeric',\n      minute: '2-digit',\n      meridiem: false\n    };\n  };\n  // Computes a default `displayEventEnd` value if one is not expliclty defined\n  TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n    return true;\n  };\n  // Renders the HTML for a single event segment's default rendering\n  TimeGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var eventUi = eventRange.ui;\n    var allDay = eventDef.allDay;\n    var isDraggable = computeEventDraggable(this.context, eventDef, eventUi);\n    var isResizableFromStart = seg.isStart && computeEventStartResizable(this.context, eventDef, eventUi);\n    var isResizableFromEnd = seg.isEnd && computeEventEndResizable(this.context, eventDef, eventUi);\n    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);\n    var skinCss = cssToStr(this.getSkinCss(eventUi));\n    var timeText;\n    var fullTimeText; // more verbose time text. for the print stylesheet\n    var startTimeText; // just the start time text\n    classes.unshift('fc-time-grid-event');\n    // if the event appears to span more than one day...\n    if (isMultiDayRange(eventRange.range)) {\n      // Don't display time text on segments that run entirely through a day.\n      // That would appear as midnight-midnight and would look dumb.\n      // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\n      if (seg.isStart || seg.isEnd) {\n        var unzonedStart = seg.start;\n        var unzonedEnd = seg.end;\n        timeText = this._getTimeText(unzonedStart, unzonedEnd, allDay); // TODO: give the timezones\n        fullTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, this.fullTimeFormat);\n        startTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, null, false); // displayEnd=false\n      }\n    } else {\n      // Display the normal time text for the *event's* times\n      timeText = this.getTimeText(eventRange);\n      fullTimeText = this.getTimeText(eventRange, this.fullTimeFormat);\n      startTimeText = this.getTimeText(eventRange, null, false); // displayEnd=false\n    }\n\n    return '<a class=\"' + classes.join(' ') + '\"' + (eventDef.url ? ' href=\"' + htmlEscape(eventDef.url) + '\"' : '') + (skinCss ? ' style=\"' + skinCss + '\"' : '') + '>' + '<div class=\"fc-content\">' + (timeText ? '<div class=\"fc-time\"' + ' data-start=\"' + htmlEscape(startTimeText) + '\"' + ' data-full=\"' + htmlEscape(fullTimeText) + '\"' + '>' + '<span>' + htmlEscape(timeText) + '</span>' + '</div>' : '') + (eventDef.title ? '<div class=\"fc-title\">' + htmlEscape(eventDef.title) + '</div>' : '') + '</div>' + (\n    /* TODO: write CSS for this\n    (isResizableFromStart ?\n      '<div class=\"fc-resizer fc-start-resizer\"></div>' :\n      ''\n      ) +\n    */\n    isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\"></div>' : '') + '</a>';\n  };\n  // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n  // Assumed the segs are already ordered.\n  // NOTE: Also reorders the given array by date!\n  TimeGridEventRenderer.prototype.computeSegHorizontals = function (segs) {\n    var levels;\n    var level0;\n    var i;\n    levels = buildSlotSegLevels(segs);\n    computeForwardSlotSegs(levels);\n    if (level0 = levels[0]) {\n      for (i = 0; i < level0.length; i++) {\n        computeSlotSegPressures(level0[i]);\n      }\n      for (i = 0; i < level0.length; i++) {\n        this.computeSegForwardBack(level0[i], 0, 0);\n      }\n    }\n  };\n  // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n  // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n  // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n  //\n  // The segment might be part of a \"series\", which means consecutive segments with the same pressure\n  // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n  // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n  // coordinate of the first segment in the series.\n  TimeGridEventRenderer.prototype.computeSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {\n    var forwardSegs = seg.forwardSegs;\n    var i;\n    if (seg.forwardCoord === undefined) {\n      // not already computed\n      if (!forwardSegs.length) {\n        // if there are no forward segments, this segment should butt up against the edge\n        seg.forwardCoord = 1;\n      } else {\n        // sort highest pressure first\n        this.sortForwardSegs(forwardSegs);\n        // this segment's forwardCoord will be calculated from the backwardCoord of the\n        // highest-pressure forward segment.\n        this.computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\n        seg.forwardCoord = forwardSegs[0].backwardCoord;\n      }\n      // calculate the backwardCoord from the forwardCoord. consider the series\n      seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / (\n      // available width for series\n      seriesBackwardPressure + 1); // # of segments in the series\n      // use this segment's coordinates to computed the coordinates of the less-pressurized\n      // forward segments\n      for (i = 0; i < forwardSegs.length; i++) {\n        this.computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\n      }\n    }\n  };\n  TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {\n    var objs = forwardSegs.map(buildTimeGridSegCompareObj);\n    var specs = [\n    // put higher-pressure first\n    {\n      field: 'forwardPressure',\n      order: -1\n    },\n    // put segments that are closer to initial edge first (and favor ones with no coords yet)\n    {\n      field: 'backwardCoord',\n      order: 1\n    }].concat(this.context.eventOrderSpecs);\n    objs.sort(function (obj0, obj1) {\n      return compareByFieldSpecs(obj0, obj1, specs);\n    });\n    return objs.map(function (c) {\n      return c._seg;\n    });\n  };\n  // Given foreground event segments that have already had their position coordinates computed,\n  // assigns position-related CSS values to their elements.\n  TimeGridEventRenderer.prototype.assignSegCss = function (segs) {\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      applyStyle(seg.el, this.generateSegCss(seg));\n      if (seg.level > 0) {\n        seg.el.classList.add('fc-time-grid-event-inset');\n      }\n      // if the event is short that the title will be cut off,\n      // attach a className that condenses the title into the time area.\n      if (seg.eventRange.def.title && seg.bottom - seg.top < 30) {\n        seg.el.classList.add('fc-short'); // TODO: \"condensed\" is a better name\n      }\n    }\n  };\n  // Generates an object with CSS properties/values that should be applied to an event segment element.\n  // Contains important positioning-related properties that should be applied to any event element, customized or not.\n  TimeGridEventRenderer.prototype.generateSegCss = function (seg) {\n    var shouldOverlap = this.context.options.slotEventOverlap;\n    var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n    var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n    var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first\n    var isRtl = this.context.isRtl;\n    var left; // amount of space from left edge, a fraction of the total width\n    var right; // amount of space from right edge, a fraction of the total width\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n    }\n    if (isRtl) {\n      left = 1 - forwardCoord;\n      right = backwardCoord;\n    } else {\n      left = backwardCoord;\n      right = 1 - forwardCoord;\n    }\n    props.zIndex = seg.level + 1; // convert from 0-base to 1-based\n    props.left = left * 100 + '%';\n    props.right = right * 100 + '%';\n    if (shouldOverlap && seg.forwardPressure) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return props;\n  };\n  return TimeGridEventRenderer;\n}(FgEventRenderer);\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\nfunction buildSlotSegLevels(segs) {\n  var levels = [];\n  var i;\n  var seg;\n  var j;\n  for (i = 0; i < segs.length; i++) {\n    seg = segs[i];\n    // go through all the levels and stop on the first level where there are no collisions\n    for (j = 0; j < levels.length; j++) {\n      if (!computeSlotSegCollisions(seg, levels[j]).length) {\n        break;\n      }\n    }\n    seg.level = j;\n    (levels[j] || (levels[j] = [])).push(seg);\n  }\n  return levels;\n}\n// For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\nfunction computeForwardSlotSegs(levels) {\n  var i;\n  var level;\n  var j;\n  var seg;\n  var k;\n  for (i = 0; i < levels.length; i++) {\n    level = levels[i];\n    for (j = 0; j < level.length; j++) {\n      seg = level[j];\n      seg.forwardSegs = [];\n      for (k = i + 1; k < levels.length; k++) {\n        computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n      }\n    }\n  }\n}\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\nfunction computeSlotSegPressures(seg) {\n  var forwardSegs = seg.forwardSegs;\n  var forwardPressure = 0;\n  var i;\n  var forwardSeg;\n  if (seg.forwardPressure === undefined) {\n    // not already computed\n    for (i = 0; i < forwardSegs.length; i++) {\n      forwardSeg = forwardSegs[i];\n      // figure out the child's maximum forward path\n      computeSlotSegPressures(forwardSeg);\n      // either use the existing maximum, or use the child's forward pressure\n      // plus one (for the forwardSeg itself)\n      forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n    }\n    seg.forwardPressure = forwardPressure;\n  }\n}\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\n  if (results === void 0) {\n    results = [];\n  }\n  for (var i = 0; i < otherSegs.length; i++) {\n    if (isSlotSegCollision(seg, otherSegs[i])) {\n      results.push(otherSegs[i]);\n    }\n  }\n  return results;\n}\n// Do these segments occupy the same vertical space?\nfunction isSlotSegCollision(seg1, seg2) {\n  return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n}\nfunction buildTimeGridSegCompareObj(seg) {\n  var obj = buildSegCompareObj(seg);\n  obj.forwardPressure = seg.forwardPressure;\n  obj.backwardCoord = seg.backwardCoord;\n  return obj;\n}\nvar TimeGridMirrorRenderer = /** @class */function (_super) {\n  __extends(TimeGridMirrorRenderer, _super);\n  function TimeGridMirrorRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    this.segsByCol = this.timeGrid.groupSegsByCol(segs);\n    this.timeGrid.attachSegsByCol(this.segsByCol, this.timeGrid.mirrorContainerEls);\n    this.sourceSeg = mirrorInfo.sourceSeg;\n  };\n  TimeGridMirrorRenderer.prototype.generateSegCss = function (seg) {\n    var props = _super.prototype.generateSegCss.call(this, seg);\n    var sourceSeg = this.sourceSeg;\n    if (sourceSeg && sourceSeg.col === seg.col) {\n      var sourceSegProps = _super.prototype.generateSegCss.call(this, sourceSeg);\n      props.left = sourceSegProps.left;\n      props.right = sourceSegProps.right;\n      props.marginLeft = sourceSegProps.marginLeft;\n      props.marginRight = sourceSegProps.marginRight;\n    }\n    return props;\n  };\n  return TimeGridMirrorRenderer;\n}(TimeGridEventRenderer);\nvar TimeGridFillRenderer = /** @class */function (_super) {\n  __extends(TimeGridFillRenderer, _super);\n  function TimeGridFillRenderer(timeGrid) {\n    var _this = _super.call(this) || this;\n    _this.timeGrid = timeGrid;\n    return _this;\n  }\n  TimeGridFillRenderer.prototype.attachSegs = function (type, segs) {\n    var timeGrid = this.timeGrid;\n    var containerEls;\n    // TODO: more efficient lookup\n    if (type === 'bgEvent') {\n      containerEls = timeGrid.bgContainerEls;\n    } else if (type === 'businessHours') {\n      containerEls = timeGrid.businessContainerEls;\n    } else if (type === 'highlight') {\n      containerEls = timeGrid.highlightContainerEls;\n    }\n    timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);\n    return segs.map(function (seg) {\n      return seg.el;\n    });\n  };\n  TimeGridFillRenderer.prototype.computeSegSizes = function (segs) {\n    this.timeGrid.computeSegVerticals(segs);\n  };\n  TimeGridFillRenderer.prototype.assignSegSizes = function (segs) {\n    this.timeGrid.assignSegVerticals(segs);\n  };\n  return TimeGridFillRenderer;\n}(FillRenderer);\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar AGENDA_STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\nvar TimeGrid = /** @class */function (_super) {\n  __extends(TimeGrid, _super);\n  function TimeGrid(el, renderProps) {\n    var _this = _super.call(this, el) || this;\n    _this.isSlatSizesDirty = false;\n    _this.isColSizesDirty = false;\n    _this.processOptions = memoize(_this._processOptions);\n    _this.renderSkeleton = memoizeRendering(_this._renderSkeleton);\n    _this.renderSlats = memoizeRendering(_this._renderSlats, null, [_this.renderSkeleton]);\n    _this.renderColumns = memoizeRendering(_this._renderColumns, _this._unrenderColumns, [_this.renderSkeleton]);\n    _this.renderProps = renderProps;\n    var renderColumns = _this.renderColumns;\n    var eventRenderer = _this.eventRenderer = new TimeGridEventRenderer(_this);\n    var fillRenderer = _this.fillRenderer = new TimeGridFillRenderer(_this);\n    _this.mirrorRenderer = new TimeGridMirrorRenderer(_this);\n    _this.renderBusinessHours = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderColumns]);\n    _this.renderDateSelection = memoizeRendering(_this._renderDateSelection, _this._unrenderDateSelection, [renderColumns]);\n    _this.renderFgEvents = memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderColumns]);\n    _this.renderBgEvents = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderColumns]);\n    _this.renderEventSelection = memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n    _this.renderEventDrag = memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderColumns]);\n    _this.renderEventResize = memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderColumns]);\n    return _this;\n  }\n  /* Options\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Parses various options into properties of this object\n  // MUST have context already set\n  TimeGrid.prototype._processOptions = function (options) {\n    var slotDuration = options.slotDuration,\n      snapDuration = options.snapDuration;\n    var snapsPerSlot;\n    var input;\n    slotDuration = createDuration(slotDuration);\n    snapDuration = snapDuration ? createDuration(snapDuration) : slotDuration;\n    snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n    if (snapsPerSlot === null) {\n      snapDuration = slotDuration;\n      snapsPerSlot = 1;\n      // TODO: say warning?\n    }\n\n    this.slotDuration = slotDuration;\n    this.snapDuration = snapDuration;\n    this.snapsPerSlot = snapsPerSlot;\n    // might be an array value (for TimelineView).\n    // if so, getting the most granular entry (the last one probably).\n    input = options.slotLabelFormat;\n    if (Array.isArray(input)) {\n      input = input[input.length - 1];\n    }\n    this.labelFormat = createFormatter(input || {\n      hour: 'numeric',\n      minute: '2-digit',\n      omitZeroMinute: true,\n      meridiem: 'short'\n    });\n    input = options.slotLabelInterval;\n    this.labelInterval = input ? createDuration(input) : this.computeLabelInterval(slotDuration);\n  };\n  // Computes an automatic value for slotLabelInterval\n  TimeGrid.prototype.computeLabelInterval = function (slotDuration) {\n    var i;\n    var labelInterval;\n    var slotsPerLabel;\n    // find the smallest stock label interval that results in more than one slots-per-label\n    for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n      labelInterval = createDuration(AGENDA_STOCK_SUB_DURATIONS[i]);\n      slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n      if (slotsPerLabel !== null && slotsPerLabel > 1) {\n        return labelInterval;\n      }\n    }\n    return slotDuration; // fall back\n  };\n  /* Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype.render = function (props, context) {\n    this.processOptions(context.options);\n    var cells = props.cells;\n    this.colCnt = cells.length;\n    this.renderSkeleton(context.theme);\n    this.renderSlats(props.dateProfile);\n    this.renderColumns(props.cells, props.dateProfile);\n    this.renderBusinessHours(context, props.businessHourSegs);\n    this.renderDateSelection(props.dateSelectionSegs);\n    this.renderFgEvents(context, props.fgEventSegs);\n    this.renderBgEvents(context, props.bgEventSegs);\n    this.renderEventSelection(props.eventSelection);\n    this.renderEventDrag(props.eventDrag);\n    this.renderEventResize(props.eventResize);\n  };\n  TimeGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    // should unrender everything else too\n    this.renderSlats.unrender();\n    this.renderColumns.unrender();\n    this.renderSkeleton.unrender();\n  };\n  TimeGrid.prototype.updateSize = function (isResize) {\n    var _a = this,\n      fillRenderer = _a.fillRenderer,\n      eventRenderer = _a.eventRenderer,\n      mirrorRenderer = _a.mirrorRenderer;\n    if (isResize || this.isSlatSizesDirty) {\n      this.buildSlatPositions();\n      this.isSlatSizesDirty = false;\n    }\n    if (isResize || this.isColSizesDirty) {\n      this.buildColPositions();\n      this.isColSizesDirty = false;\n    }\n    fillRenderer.computeSizes(isResize);\n    eventRenderer.computeSizes(isResize);\n    mirrorRenderer.computeSizes(isResize);\n    fillRenderer.assignSizes(isResize);\n    eventRenderer.assignSizes(isResize);\n    mirrorRenderer.assignSizes(isResize);\n  };\n  TimeGrid.prototype._renderSkeleton = function (theme) {\n    var el = this.el;\n    el.innerHTML = '<div class=\"fc-bg\"></div>' + '<div class=\"fc-slats\"></div>' + '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" style=\"display:none\" />';\n    this.rootBgContainerEl = el.querySelector('.fc-bg');\n    this.slatContainerEl = el.querySelector('.fc-slats');\n    this.bottomRuleEl = el.querySelector('.fc-divider');\n  };\n  TimeGrid.prototype._renderSlats = function (dateProfile) {\n    var theme = this.context.theme;\n    this.slatContainerEl.innerHTML = '<table class=\"' + theme.getClass('tableGrid') + '\">' + this.renderSlatRowHtml(dateProfile) + '</table>';\n    this.slatEls = findElements(this.slatContainerEl, 'tr');\n    this.slatPositions = new PositionCache(this.el, this.slatEls, false, true // vertical\n    );\n\n    this.isSlatSizesDirty = true;\n  };\n  // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n  TimeGrid.prototype.renderSlatRowHtml = function (dateProfile) {\n    var _a = this.context,\n      dateEnv = _a.dateEnv,\n      theme = _a.theme,\n      isRtl = _a.isRtl;\n    var html = '';\n    var dayStart = startOfDay(dateProfile.renderRange.start);\n    var slotTime = dateProfile.minTime;\n    var slotIterator = createDuration(0);\n    var slotDate; // will be on the view's first day, but we only care about its time\n    var isLabeled;\n    var axisHtml;\n    // Calculate the time for each slot\n    while (asRoughMs(slotTime) < asRoughMs(dateProfile.maxTime)) {\n      slotDate = dateEnv.add(dayStart, slotTime);\n      isLabeled = wholeDivideDurations(slotIterator, this.labelInterval) !== null;\n      axisHtml = '<td class=\"fc-axis fc-time ' + theme.getClass('widgetContent') + '\">' + (isLabeled ? '<span>' +\n      // for matchCellWidths\n      htmlEscape(dateEnv.format(slotDate, this.labelFormat)) + '</span>' : '') + '</td>';\n      html += '<tr data-time=\"' + formatIsoTimeString(slotDate) + '\"' + (isLabeled ? '' : ' class=\"fc-minor\"') + '>' + (!isRtl ? axisHtml : '') + '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' + (isRtl ? axisHtml : '') + '</tr>';\n      slotTime = addDurations(slotTime, this.slotDuration);\n      slotIterator = addDurations(slotIterator, this.slotDuration);\n    }\n    return html;\n  };\n  TimeGrid.prototype._renderColumns = function (cells, dateProfile) {\n    var _a = this.context,\n      calendar = _a.calendar,\n      view = _a.view,\n      isRtl = _a.isRtl,\n      theme = _a.theme,\n      dateEnv = _a.dateEnv;\n    var bgRow = new DayBgRow(this.context);\n    this.rootBgContainerEl.innerHTML = '<table class=\"' + theme.getClass('tableGrid') + '\">' + bgRow.renderHtml({\n      cells: cells,\n      dateProfile: dateProfile,\n      renderIntroHtml: this.renderProps.renderBgIntroHtml\n    }) + '</table>';\n    this.colEls = findElements(this.el, '.fc-day, .fc-disabled-day');\n    for (var col = 0; col < this.colCnt; col++) {\n      calendar.publiclyTrigger('dayRender', [{\n        date: dateEnv.toDate(cells[col].date),\n        el: this.colEls[col],\n        view: view\n      }]);\n    }\n    if (isRtl) {\n      this.colEls.reverse();\n    }\n    this.colPositions = new PositionCache(this.el, this.colEls, true,\n    // horizontal\n    false);\n    this.renderContentSkeleton();\n    this.isColSizesDirty = true;\n  };\n  TimeGrid.prototype._unrenderColumns = function () {\n    this.unrenderContentSkeleton();\n  };\n  /* Content Skeleton\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Renders the DOM that the view's content will live in\n  TimeGrid.prototype.renderContentSkeleton = function () {\n    var isRtl = this.context.isRtl;\n    var parts = [];\n    var skeletonEl;\n    parts.push(this.renderProps.renderIntroHtml());\n    for (var i = 0; i < this.colCnt; i++) {\n      parts.push('<td>' + '<div class=\"fc-content-col\">' + '<div class=\"fc-event-container fc-mirror-container\"></div>' + '<div class=\"fc-event-container\"></div>' + '<div class=\"fc-highlight-container\"></div>' + '<div class=\"fc-bgevent-container\"></div>' + '<div class=\"fc-business-container\"></div>' + '</div>' + '</td>');\n    }\n    if (isRtl) {\n      parts.reverse();\n    }\n    skeletonEl = this.contentSkeletonEl = htmlToElement('<div class=\"fc-content-skeleton\">' + '<table>' + '<tr>' + parts.join('') + '</tr>' + '</table>' + '</div>');\n    this.colContainerEls = findElements(skeletonEl, '.fc-content-col');\n    this.mirrorContainerEls = findElements(skeletonEl, '.fc-mirror-container');\n    this.fgContainerEls = findElements(skeletonEl, '.fc-event-container:not(.fc-mirror-container)');\n    this.bgContainerEls = findElements(skeletonEl, '.fc-bgevent-container');\n    this.highlightContainerEls = findElements(skeletonEl, '.fc-highlight-container');\n    this.businessContainerEls = findElements(skeletonEl, '.fc-business-container');\n    if (isRtl) {\n      this.colContainerEls.reverse();\n      this.mirrorContainerEls.reverse();\n      this.fgContainerEls.reverse();\n      this.bgContainerEls.reverse();\n      this.highlightContainerEls.reverse();\n      this.businessContainerEls.reverse();\n    }\n    this.el.appendChild(skeletonEl);\n  };\n  TimeGrid.prototype.unrenderContentSkeleton = function () {\n    removeElement(this.contentSkeletonEl);\n  };\n  // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\n  TimeGrid.prototype.groupSegsByCol = function (segs) {\n    var segsByCol = [];\n    var i;\n    for (i = 0; i < this.colCnt; i++) {\n      segsByCol.push([]);\n    }\n    for (i = 0; i < segs.length; i++) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n    return segsByCol;\n  };\n  // Given segments grouped by column, insert the segments' elements into a parallel array of container\n  // elements, each living within a column.\n  TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {\n    var col;\n    var segs;\n    var i;\n    for (col = 0; col < this.colCnt; col++) {\n      // iterate each column grouping\n      segs = segsByCol[col];\n      for (i = 0; i < segs.length; i++) {\n        containerEls[col].appendChild(segs[i].el);\n      }\n    }\n  };\n  /* Now Indicator\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype.getNowIndicatorUnit = function () {\n    return 'minute'; // will refresh on the minute\n  };\n\n  TimeGrid.prototype.renderNowIndicator = function (segs, date) {\n    // HACK: if date columns not ready for some reason (scheduler)\n    if (!this.colContainerEls) {\n      return;\n    }\n    var top = this.computeDateTop(date);\n    var nodes = [];\n    var i;\n    // render lines within the columns\n    for (i = 0; i < segs.length; i++) {\n      var lineEl = createElement('div', {\n        className: 'fc-now-indicator fc-now-indicator-line'\n      });\n      lineEl.style.top = top + 'px';\n      this.colContainerEls[segs[i].col].appendChild(lineEl);\n      nodes.push(lineEl);\n    }\n    // render an arrow over the axis\n    if (segs.length > 0) {\n      // is the current time in view?\n      var arrowEl = createElement('div', {\n        className: 'fc-now-indicator fc-now-indicator-arrow'\n      });\n      arrowEl.style.top = top + 'px';\n      this.contentSkeletonEl.appendChild(arrowEl);\n      nodes.push(arrowEl);\n    }\n    this.nowIndicatorEls = nodes;\n  };\n  TimeGrid.prototype.unrenderNowIndicator = function () {\n    if (this.nowIndicatorEls) {\n      this.nowIndicatorEls.forEach(removeElement);\n      this.nowIndicatorEls = null;\n    }\n  };\n  /* Coordinates\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype.getTotalSlatHeight = function () {\n    return this.slatContainerEl.getBoundingClientRect().height;\n  };\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  TimeGrid.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when);\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  };\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  TimeGrid.prototype.computeTimeTop = function (duration) {\n    var len = this.slatEls.length;\n    var dateProfile = this.props.dateProfile;\n    var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.minTime)) / asRoughMs(this.slotDuration); // floating-point value of # of slots covered\n    var slatIndex;\n    var slatRemainder;\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because minTime/maxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage);\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1);\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex;\n    return this.slatPositions.tops[slatIndex] + this.slatPositions.getHeight(slatIndex) * slatRemainder;\n  };\n  // For each segment in an array, computes and assigns its top and bottom properties\n  TimeGrid.prototype.computeSegVerticals = function (segs) {\n    var options = this.context.options;\n    var eventMinHeight = options.timeGridEventMinHeight;\n    var i;\n    var seg;\n    var dayDate;\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      dayDate = this.props.cells[seg.col].date;\n      seg.top = this.computeDateTop(seg.start, dayDate);\n      seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.end, dayDate));\n    }\n  };\n  // Given segments that already have their top/bottom properties computed, applies those values to\n  // the segments' elements.\n  TimeGrid.prototype.assignSegVerticals = function (segs) {\n    var i;\n    var seg;\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      applyStyle(seg.el, this.generateSegVerticalCss(seg));\n    }\n  };\n  // Generates an object with CSS properties for the top/bottom coordinates of a segment element\n  TimeGrid.prototype.generateSegVerticalCss = function (seg) {\n    return {\n      top: seg.top,\n      bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\n    };\n  };\n  /* Sizing\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype.buildPositionCaches = function () {\n    this.buildColPositions();\n    this.buildSlatPositions();\n  };\n  TimeGrid.prototype.buildColPositions = function () {\n    this.colPositions.build();\n  };\n  TimeGrid.prototype.buildSlatPositions = function () {\n    this.slatPositions.build();\n  };\n  /* Hit System\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype.positionToHit = function (positionLeft, positionTop) {\n    var dateEnv = this.context.dateEnv;\n    var _a = this,\n      snapsPerSlot = _a.snapsPerSlot,\n      slatPositions = _a.slatPositions,\n      colPositions = _a.colPositions;\n    var colIndex = colPositions.leftToIndex(positionLeft);\n    var slatIndex = slatPositions.topToIndex(positionTop);\n    if (colIndex != null && slatIndex != null) {\n      var slatTop = slatPositions.tops[slatIndex];\n      var slatHeight = slatPositions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = addDurations(this.props.dateProfile.minTime, multiplyDuration(this.snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, this.snapDuration);\n      return {\n        col: colIndex,\n        dateSpan: {\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        },\n        dayEl: this.colEls[colIndex],\n        relativeRect: {\n          left: colPositions.lefts[colIndex],\n          right: colPositions.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        }\n      };\n    }\n  };\n  /* Event Drag Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype._renderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      if (state.isEvent) {\n        this.mirrorRenderer.renderSegs(this.context, state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      } else {\n        this.fillRenderer.renderSegs('highlight', this.context, state.segs);\n      }\n    }\n  };\n  TimeGrid.prototype._unrenderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      if (state.isEvent) {\n        this.mirrorRenderer.unrender(this.context, state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      } else {\n        this.fillRenderer.unrender('highlight', this.context);\n      }\n    }\n  };\n  /* Event Resize Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeGrid.prototype._renderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      this.mirrorRenderer.renderSegs(this.context, state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n  TimeGrid.prototype._unrenderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.mirrorRenderer.unrender(this.context, state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n  /* Selection\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\n  TimeGrid.prototype._renderDateSelection = function (segs) {\n    if (segs) {\n      if (this.context.options.selectMirror) {\n        this.mirrorRenderer.renderSegs(this.context, segs, {\n          isSelecting: true\n        });\n      } else {\n        this.fillRenderer.renderSegs('highlight', this.context, segs);\n      }\n    }\n  };\n  TimeGrid.prototype._unrenderDateSelection = function (segs) {\n    if (segs) {\n      if (this.context.options.selectMirror) {\n        this.mirrorRenderer.unrender(this.context, segs, {\n          isSelecting: true\n        });\n      } else {\n        this.fillRenderer.unrender('highlight', this.context);\n      }\n    }\n  };\n  return TimeGrid;\n}(DateComponent);\nvar AllDaySplitter = /** @class */function (_super) {\n  __extends(AllDaySplitter, _super);\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    } else {\n      return ['timed'];\n    }\n  };\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    } else if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    } else {\n      return ['allDay'];\n    }\n  };\n  return AllDaySplitter;\n}(Splitter);\nvar TIMEGRID_ALL_DAY_EVENT_LIMIT = 5;\nvar WEEK_HEADER_FORMAT = createFormatter({\n  week: 'short'\n});\n/* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\nvar AbstractTimeGridView = /** @class */function (_super) {\n  __extends(AbstractTimeGridView, _super);\n  function AbstractTimeGridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.splitter = new AllDaySplitter();\n    _this.renderSkeleton = memoizeRendering(_this._renderSkeleton, _this._unrenderSkeleton);\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that will go before the day-of week header cells\n    _this.renderHeadIntroHtml = function () {\n      var _a = _this.context,\n        theme = _a.theme,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n      var range = _this.props.dateProfile.renderRange;\n      var dayCnt = diffDays(range.start, range.end);\n      var weekText;\n      if (options.weekNumbers) {\n        weekText = dateEnv.format(range.start, WEEK_HEADER_FORMAT);\n        return '' + '<th class=\"fc-axis fc-week-number ' + theme.getClass('widgetHeader') + '\" ' + _this.axisStyleAttr() + '>' + buildGotoAnchorHtml(\n        // aside from link, important for matchCellWidths\n        options, dateEnv, {\n          date: range.start,\n          type: 'week',\n          forceOff: dayCnt > 1\n        }, htmlEscape(weekText) // inner HTML\n        ) + '</th>';\n      } else {\n        return '<th class=\"fc-axis ' + theme.getClass('widgetHeader') + '\" ' + _this.axisStyleAttr() + '></th>';\n      }\n    };\n    /* Time Grid Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\n    _this.renderTimeGridBgIntroHtml = function () {\n      var theme = _this.context.theme;\n      return '<td class=\"fc-axis ' + theme.getClass('widgetContent') + '\" ' + _this.axisStyleAttr() + '></td>';\n    };\n    // Generates the HTML that goes before all other types of cells.\n    // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.\n    _this.renderTimeGridIntroHtml = function () {\n      return '<td class=\"fc-axis\" ' + _this.axisStyleAttr() + '></td>';\n    };\n    /* Day Grid Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that goes before the all-day cells\n    _this.renderDayGridBgIntroHtml = function () {\n      var _a = _this.context,\n        theme = _a.theme,\n        options = _a.options;\n      return '' + '<td class=\"fc-axis ' + theme.getClass('widgetContent') + '\" ' + _this.axisStyleAttr() + '>' + '<span>' +\n      // needed for matchCellWidths\n      getAllDayHtml(options) + '</span>' + '</td>';\n    };\n    // Generates the HTML that goes before all other types of cells.\n    // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.\n    _this.renderDayGridIntroHtml = function () {\n      return '<td class=\"fc-axis\" ' + _this.axisStyleAttr() + '></td>';\n    };\n    return _this;\n  }\n  AbstractTimeGridView.prototype.render = function (props, context) {\n    _super.prototype.render.call(this, props, context);\n    this.renderSkeleton(context);\n  };\n  AbstractTimeGridView.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.renderSkeleton.unrender();\n  };\n  AbstractTimeGridView.prototype._renderSkeleton = function (context) {\n    this.el.classList.add('fc-timeGrid-view');\n    this.el.innerHTML = this.renderSkeletonHtml();\n    this.scroller = new ScrollComponent('hidden',\n    // overflow x\n    'auto' // overflow y\n    );\n\n    var timeGridWrapEl = this.scroller.el;\n    this.el.querySelector('.fc-body > tr > td').appendChild(timeGridWrapEl);\n    timeGridWrapEl.classList.add('fc-time-grid-container');\n    var timeGridEl = createElement('div', {\n      className: 'fc-time-grid'\n    });\n    timeGridWrapEl.appendChild(timeGridEl);\n    this.timeGrid = new TimeGrid(timeGridEl, {\n      renderBgIntroHtml: this.renderTimeGridBgIntroHtml,\n      renderIntroHtml: this.renderTimeGridIntroHtml\n    });\n    if (context.options.allDaySlot) {\n      // should we display the \"all-day\" area?\n      this.dayGrid = new DayGrid(\n      // the all-day subcomponent of this view\n      this.el.querySelector('.fc-day-grid'), {\n        renderNumberIntroHtml: this.renderDayGridIntroHtml,\n        renderBgIntroHtml: this.renderDayGridBgIntroHtml,\n        renderIntroHtml: this.renderDayGridIntroHtml,\n        colWeekNumbersVisible: false,\n        cellWeekNumbersVisible: false\n      });\n      // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\n      var dividerEl = this.el.querySelector('.fc-divider');\n      this.dayGrid.bottomCoordPadding = dividerEl.getBoundingClientRect().height;\n    }\n  };\n  AbstractTimeGridView.prototype._unrenderSkeleton = function () {\n    this.el.classList.remove('fc-timeGrid-view');\n    this.timeGrid.destroy();\n    if (this.dayGrid) {\n      this.dayGrid.destroy();\n    }\n    this.scroller.destroy();\n  };\n  /* Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds the HTML skeleton for the view.\n  // The day-grid and time-grid components will render inside containers defined by this HTML.\n  AbstractTimeGridView.prototype.renderSkeletonHtml = function () {\n    var _a = this.context,\n      theme = _a.theme,\n      options = _a.options;\n    return '' + '<table class=\"' + theme.getClass('tableGrid') + '\">' + (options.columnHeader ? '<thead class=\"fc-head\">' + '<tr>' + '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class=\"fc-body\">' + '<tr>' + '<td class=\"' + theme.getClass('widgetContent') + '\">' + (options.allDaySlot ? '<div class=\"fc-day-grid\"></div>' + '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" />' : '') + '</td>' + '</tr>' + '</tbody>' + '</table>';\n  };\n  /* Now Indicator\n  ------------------------------------------------------------------------------------------------------------------*/\n  AbstractTimeGridView.prototype.getNowIndicatorUnit = function () {\n    return this.timeGrid.getNowIndicatorUnit();\n  };\n  // subclasses should implement\n  // renderNowIndicator(date: DateMarker) {\n  // }\n  AbstractTimeGridView.prototype.unrenderNowIndicator = function () {\n    this.timeGrid.unrenderNowIndicator();\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n  AbstractTimeGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {\n    _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first\n    this.timeGrid.updateSize(isResize);\n    if (this.dayGrid) {\n      this.dayGrid.updateSize(isResize);\n    }\n  };\n  // Adjusts the vertical dimensions of the view to the specified values\n  AbstractTimeGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {\n    var _this = this;\n    var eventLimit;\n    var scrollerHeight;\n    var scrollbarWidths;\n    // make all axis cells line up\n    this.axisWidth = matchCellWidths(findElements(this.el, '.fc-axis'));\n    // hack to give the view some height prior to timeGrid's columns being rendered\n    // TODO: separate setting height from scroller VS timeGrid.\n    if (!this.timeGrid.colEls) {\n      if (!isAuto) {\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      }\n      return;\n    }\n    // set of fake row elements that must compensate when scroller has scrollbars\n    var noScrollRowEls = findElements(this.el, '.fc-row').filter(function (node) {\n      return !_this.scroller.el.contains(node);\n    });\n    // reset all dimensions back to the original state\n    this.timeGrid.bottomRuleEl.style.display = 'none'; // will be shown later if this <hr> is necessary\n    this.scroller.clear(); // sets height to 'auto' and clears overflow\n    noScrollRowEls.forEach(uncompensateScroll);\n    // limit number of events in the all-day area\n    if (this.dayGrid) {\n      this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n      eventLimit = this.context.options.eventLimit;\n      if (eventLimit && typeof eventLimit !== 'number') {\n        eventLimit = TIMEGRID_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\n      }\n\n      if (eventLimit) {\n        this.dayGrid.limitRows(eventLimit);\n      }\n    }\n    if (!isAuto) {\n      // should we force dimensions of the scroll container?\n      scrollerHeight = this.computeScrollerHeight(viewHeight);\n      this.scroller.setHeight(scrollerHeight);\n      scrollbarWidths = this.scroller.getScrollbarWidths();\n      if (scrollbarWidths.left || scrollbarWidths.right) {\n        // using scrollbars?\n        // make the all-day and header rows lines up\n        noScrollRowEls.forEach(function (rowEl) {\n          compensateScroll(rowEl, scrollbarWidths);\n        });\n        // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\n        // and reapply the desired height to the scroller.\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      }\n      // guarantees the same scrollbar widths\n      this.scroller.lockOverflow(scrollbarWidths);\n      // if there's any space below the slats, show the horizontal rule.\n      // this won't cause any new overflow, because lockOverflow already called.\n      if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\n        this.timeGrid.bottomRuleEl.style.display = '';\n      }\n    }\n  };\n  // given a desired total height of the view, returns what the height of the scroller should be\n  AbstractTimeGridView.prototype.computeScrollerHeight = function (viewHeight) {\n    return viewHeight - subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n  };\n  /* Scroll\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Computes the initial pre-configured scroll state prior to allowing the user to change it\n  AbstractTimeGridView.prototype.computeDateScroll = function (duration) {\n    var top = this.timeGrid.computeTimeTop(duration);\n    // zoom can give weird floating-point values. rather scroll a little bit further\n    top = Math.ceil(top);\n    if (top) {\n      top++; // to overcome top border that slots beyond the first have. looks better\n    }\n\n    return {\n      top: top\n    };\n  };\n  AbstractTimeGridView.prototype.queryDateScroll = function () {\n    return {\n      top: this.scroller.getScrollTop()\n    };\n  };\n  AbstractTimeGridView.prototype.applyDateScroll = function (scroll) {\n    if (scroll.top !== undefined) {\n      this.scroller.setScrollTop(scroll.top);\n    }\n  };\n  // Generates an HTML attribute string for setting the width of the axis, if it is known\n  AbstractTimeGridView.prototype.axisStyleAttr = function () {\n    if (this.axisWidth != null) {\n      return 'style=\"width:' + this.axisWidth + 'px\"';\n    }\n    return '';\n  };\n  return AbstractTimeGridView;\n}(View);\nAbstractTimeGridView.prototype.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering\n\nvar SimpleTimeGrid = /** @class */function (_super) {\n  __extends(SimpleTimeGrid, _super);\n  function SimpleTimeGrid(timeGrid) {\n    var _this = _super.call(this, timeGrid.el) || this;\n    _this.buildDayRanges = memoize(buildDayRanges);\n    _this.slicer = new TimeGridSlicer();\n    _this.timeGrid = timeGrid;\n    return _this;\n  }\n  SimpleTimeGrid.prototype.firstContext = function (context) {\n    context.calendar.registerInteractiveComponent(this, {\n      el: this.timeGrid.el\n    });\n  };\n  SimpleTimeGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.context.calendar.unregisterInteractiveComponent(this);\n  };\n  SimpleTimeGrid.prototype.render = function (props, context) {\n    var dateEnv = this.context.dateEnv;\n    var dateProfile = props.dateProfile,\n      dayTable = props.dayTable;\n    var dayRanges = this.dayRanges = this.buildDayRanges(dayTable, dateProfile, dateEnv);\n    var timeGrid = this.timeGrid;\n    timeGrid.receiveContext(context); // hack because context is used in sliceProps\n    timeGrid.receiveProps(__assign({}, this.slicer.sliceProps(props, dateProfile, null, context.calendar, timeGrid, dayRanges), {\n      dateProfile: dateProfile,\n      cells: dayTable.cells[0]\n    }), context);\n  };\n  SimpleTimeGrid.prototype.renderNowIndicator = function (date) {\n    this.timeGrid.renderNowIndicator(this.slicer.sliceNowDate(date, this.timeGrid, this.dayRanges), date);\n  };\n  SimpleTimeGrid.prototype.buildPositionCaches = function () {\n    this.timeGrid.buildPositionCaches();\n  };\n  SimpleTimeGrid.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.timeGrid.positionToHit(positionLeft, positionTop);\n    if (rawHit) {\n      return {\n        component: this.timeGrid,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n  };\n  return SimpleTimeGrid;\n}(DateComponent);\nfunction buildDayRanges(dayTable, dateProfile, dateEnv) {\n  var ranges = [];\n  for (var _i = 0, _a = dayTable.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.minTime),\n      end: dateEnv.add(date, dateProfile.maxTime)\n    });\n  }\n  return ranges;\n}\nvar TimeGridSlicer = /** @class */function (_super) {\n  __extends(TimeGridSlicer, _super);\n  function TimeGridSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeGridSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n    for (var col = 0; col < dayRanges.length; col++) {\n      var segRange = intersectRanges(range, dayRanges[col]);\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n    return segs;\n  };\n  return TimeGridSlicer;\n}(Slicer);\nvar TimeGridView = /** @class */function (_super) {\n  __extends(TimeGridView, _super);\n  function TimeGridView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.buildDayTable = memoize(buildDayTable);\n    return _this;\n  }\n  TimeGridView.prototype.render = function (props, context) {\n    _super.prototype.render.call(this, props, context); // for flags for updateSize. also _renderSkeleton/_unrenderSkeleton\n    var _a = this.props,\n      dateProfile = _a.dateProfile,\n      dateProfileGenerator = _a.dateProfileGenerator;\n    var nextDayThreshold = context.nextDayThreshold;\n    var dayTable = this.buildDayTable(dateProfile, dateProfileGenerator);\n    var splitProps = this.splitter.splitProps(props);\n    if (this.header) {\n      this.header.receiveProps({\n        dateProfile: dateProfile,\n        dates: dayTable.headerDates,\n        datesRepDistinctDays: true,\n        renderIntroHtml: this.renderHeadIntroHtml\n      }, context);\n    }\n    this.simpleTimeGrid.receiveProps(__assign({}, splitProps['timed'], {\n      dateProfile: dateProfile,\n      dayTable: dayTable\n    }), context);\n    if (this.simpleDayGrid) {\n      this.simpleDayGrid.receiveProps(__assign({}, splitProps['allDay'], {\n        dateProfile: dateProfile,\n        dayTable: dayTable,\n        nextDayThreshold: nextDayThreshold,\n        isRigid: false\n      }), context);\n    }\n    this.startNowIndicator(dateProfile, dateProfileGenerator);\n  };\n  TimeGridView.prototype._renderSkeleton = function (context) {\n    _super.prototype._renderSkeleton.call(this, context);\n    if (context.options.columnHeader) {\n      this.header = new DayHeader(this.el.querySelector('.fc-head-container'));\n    }\n    this.simpleTimeGrid = new SimpleTimeGrid(this.timeGrid);\n    if (this.dayGrid) {\n      this.simpleDayGrid = new SimpleDayGrid(this.dayGrid);\n    }\n  };\n  TimeGridView.prototype._unrenderSkeleton = function () {\n    _super.prototype._unrenderSkeleton.call(this);\n    if (this.header) {\n      this.header.destroy();\n    }\n    this.simpleTimeGrid.destroy();\n    if (this.simpleDayGrid) {\n      this.simpleDayGrid.destroy();\n    }\n  };\n  TimeGridView.prototype.renderNowIndicator = function (date) {\n    this.simpleTimeGrid.renderNowIndicator(date);\n  };\n  return TimeGridView;\n}(AbstractTimeGridView);\nfunction buildDayTable(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeries(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTable(daySeries, false);\n}\nvar main = createPlugin({\n  defaultView: 'timeGridWeek',\n  views: {\n    timeGrid: {\n      class: TimeGridView,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n    },\n\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { AbstractTimeGridView, TimeGrid, TimeGridSlicer, TimeGridView, buildDayRanges, buildDayTable };","map":null,"metadata":{},"sourceType":"module"}