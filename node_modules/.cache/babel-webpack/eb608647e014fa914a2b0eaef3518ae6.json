{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Frequency } from './types';\nimport { Weekday } from './weekday';\nimport dateutil from './dateutil';\nimport { Days } from './rrule';\nexport function parseString(rfcString) {\n  var options = rfcString.split('\\n').map(parseLine).filter(function (x) {\n    return x !== null;\n  });\n  return __assign(__assign({}, options[0]), options[1]);\n}\nexport function parseDtstart(line) {\n  var options = {};\n  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\\s]+)/i.exec(line);\n  if (!dtstartWithZone) {\n    return options;\n  }\n  var _ = dtstartWithZone[0],\n    tzid = dtstartWithZone[1],\n    dtstart = dtstartWithZone[2];\n  if (tzid) {\n    options.tzid = tzid;\n  }\n  options.dtstart = dateutil.untilStringToDate(dtstart);\n  return options;\n}\nfunction parseLine(rfcString) {\n  rfcString = rfcString.replace(/^\\s+|\\s+$/, '');\n  if (!rfcString.length) return null;\n  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());\n  if (!header) {\n    return parseRrule(rfcString);\n  }\n  var _ = header[0],\n    key = header[1];\n  switch (key.toUpperCase()) {\n    case 'RRULE':\n    case 'EXRULE':\n      return parseRrule(rfcString);\n    case 'DTSTART':\n      return parseDtstart(rfcString);\n    default:\n      throw new Error(\"Unsupported RFC prop \" + key + \" in \" + rfcString);\n  }\n}\nfunction parseRrule(line) {\n  var strippedLine = line.replace(/^RRULE:/i, '');\n  var options = parseDtstart(strippedLine);\n  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, '').split(';');\n  attrs.forEach(function (attr) {\n    var _a = attr.split('='),\n      key = _a[0],\n      value = _a[1];\n    switch (key.toUpperCase()) {\n      case 'FREQ':\n        options.freq = Frequency[value.toUpperCase()];\n        break;\n      case 'WKST':\n        options.wkst = Days[value.toUpperCase()];\n        break;\n      case 'COUNT':\n      case 'INTERVAL':\n      case 'BYSETPOS':\n      case 'BYMONTH':\n      case 'BYMONTHDAY':\n      case 'BYYEARDAY':\n      case 'BYWEEKNO':\n      case 'BYHOUR':\n      case 'BYMINUTE':\n      case 'BYSECOND':\n        var num = parseNumber(value);\n        var optionKey = key.toLowerCase();\n        // @ts-ignore\n        options[optionKey] = num;\n        break;\n      case 'BYWEEKDAY':\n      case 'BYDAY':\n        options.byweekday = parseWeekday(value);\n        break;\n      case 'DTSTART':\n      case 'TZID':\n        // for backwards compatibility\n        var dtstart = parseDtstart(line);\n        options.tzid = dtstart.tzid;\n        options.dtstart = dtstart.dtstart;\n        break;\n      case 'UNTIL':\n        options.until = dateutil.untilStringToDate(value);\n        break;\n      case 'BYEASTER':\n        options.byeaster = Number(value);\n        break;\n      default:\n        throw new Error(\"Unknown RRULE property '\" + key + \"'\");\n    }\n  });\n  return options;\n}\nfunction parseNumber(value) {\n  if (value.indexOf(',') !== -1) {\n    var values = value.split(',');\n    return values.map(parseIndividualNumber);\n  }\n  return parseIndividualNumber(value);\n}\nfunction parseIndividualNumber(value) {\n  if (/^[+-]?\\d+$/.test(value)) {\n    return Number(value);\n  }\n  return value;\n}\nfunction parseWeekday(value) {\n  var days = value.split(',');\n  return days.map(function (day) {\n    if (day.length === 2) {\n      // MO, TU, ...\n      return Days[day]; // wday instanceof Weekday\n    }\n    // -1MO, +3FR, 1SO, 13TU ...\n    var parts = day.match(/^([+-]?\\d{1,2})([A-Z]{2})$/);\n    var n = Number(parts[1]);\n    var wdaypart = parts[2];\n    var wday = Days[wdaypart].weekday;\n    return new Weekday(wday, n);\n  });\n}\n//# sourceMappingURL=parsestring.js.map","map":null,"metadata":{},"sourceType":"module"}