{"ast":null,"code":"import flat from 'flat';\nimport { take, map, catchError, retry, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { InjectionToken, Inject, Injectable, Injector, Optional, APP_INITIALIZER, NgModule, Component, Input, ChangeDetectorRef, Directive, ElementRef, TemplateRef, ViewContainerRef, Pipe, ComponentFactoryResolver, defineInjectable, inject } from '@angular/core';\nimport { of, from, BehaviorSubject, combineLatest, EMPTY, forkJoin, Subject } from 'rxjs';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.loader.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as Éµngcc0 from '@angular/core';\nclass DefaultLoader {\n  /**\n   * @param {?} translations\n   */\n  constructor(translations) {\n    this.translations = translations;\n  }\n  /**\n   * @param {?} lang\n   * @return {?}\n   */\n  getTranslation(lang) {\n    return of(this.translations.get(lang) || {});\n  }\n}\n/** @type {?} */\nconst TRANSLOCO_LOADER = new InjectionToken('TRANSLOCO_LOADER');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/helpers.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} obj\n * @param {?} path\n * @return {?}\n */\nfunction getValue(obj, path) {\n  /* For cases where the key is like: 'general.something.thing' */\n  if (obj && obj.hasOwnProperty(path)) {\n    return obj[path];\n  }\n  return path.split('.').reduce(\n  /**\n  * @param {?} p\n  * @param {?} c\n  * @return {?}\n  */\n  (p, c) => p && p[c], obj);\n}\n/**\n * @param {?} obj\n * @param {?} prop\n * @param {?} val\n * @return {?}\n */\nfunction setValue(obj, prop, val) {\n  obj = Object.assign({}, obj);\n  /** @type {?} */\n  const split = prop.split('.');\n  /** @type {?} */\n  const lastIndex = split.length - 1;\n  split.reduce(\n  /**\n  * @param {?} acc\n  * @param {?} part\n  * @param {?} index\n  * @return {?}\n  */\n  (acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n}\n/**\n * @param {?} collection\n * @return {?}\n */\nfunction size(collection) {\n  if (!collection) {\n    return 0;\n  }\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n  return !!collection ? collection.length : 0;\n}\n/**\n * @param {?} collection\n * @return {?}\n */\nfunction isEmpty(collection) {\n  return size(collection) === 0;\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n/**\n * @param {?} item\n * @return {?}\n */\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction coerceArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\n/**\n * @param {?} str\n * @return {?}\n */\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,\n  /**\n  * @param {?} word\n  * @param {?} index\n  * @return {?}\n  */\n  (word, index) => index == 0 ? word.toLowerCase() : word.toUpperCase()).replace(/\\s+|_|-|\\//g, '');\n}\n/**\n * @return {?}\n */\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isDefined(value) {\n  return isNil(value) === false;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toNumber(value) {\n  if (isNumber(value)) return value;\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n  return null;\n}\n/**\n * @param {?} item\n * @return {?}\n */\nfunction isScopeObject(item) {\n  return item && typeof item.scope === 'string';\n}\n/**\n * @param {?} item\n * @return {?}\n */\nfunction hasInlineLoader(item) {\n  return item && isObject(item.loader);\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction unflatten(obj) {\n  return flat.unflatten(obj, {\n    safe: true\n  });\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction flatten(obj) {\n  return flat(obj, {\n    safe: true\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  () => {\n    return {};\n  }\n});\n/** @type {?} */\nconst defaultConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  },\n  interpolation: ['{{', '}}']\n};\n/**\n * @deprecated\n * @param {?=} config\n * @return {?}\n */\nfunction provideTranslocoConfig(config = defaultConfig) {\n  return {\n    provide: TRANSLOCO_CONFIG,\n    useValue: Object.assign({}, defaultConfig, config)\n  };\n}\n/**\n * Sets up TranslocoConfig object.\n *\n * @param {?=} config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n * @return {?}\n */\nfunction translocoConfig(config = defaultConfig) {\n  return Object.assign({}, defaultConfig, config);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.transpiler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\nclass DefaultTranspiler {\n  /**\n   * @param {?=} userConfig\n   */\n  constructor(userConfig) {\n    this.interpolationMatcher = resolveMatcher(userConfig);\n  }\n  /**\n   * @param {?} value\n   * @param {?=} params\n   * @param {?=} translation\n   * @return {?}\n   */\n  transpile(value, params = {}, translation) {\n    if (isString(value)) {\n      return value.replace(this.interpolationMatcher,\n      /**\n      * @param {?} _\n      * @param {?} match\n      * @return {?}\n      */\n      (_, match) => {\n        match = match.trim();\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';\n      });\n    } else if (params) {\n      if (isObject(value)) {\n        value = this.handleObject(value, params, translation);\n      } else if (Array.isArray(value)) {\n        value = this.handleArray(value, params, translation);\n      }\n    }\n    return value;\n  }\n  /**\n   *\n   * \\@example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   * @protected\n   * @param {?} value\n   * @param {?=} params\n   * @param {?=} translation\n   * @return {?}\n   */\n  handleObject(value, params = {}, translation) {\n    /** @type {?} */\n    let result = value;\n    Object.keys(params).forEach(\n    /**\n    * @param {?} p\n    * @return {?}\n    */\n    p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      /** @type {?} */\n      const v = getValue(result, p);\n      // get the params of \"b.c\" => { value: \"Transloco\" }\n      /** @type {?} */\n      const getParams = getValue(params, p);\n      // transpile the value => \"Hello Transloco\"\n      /** @type {?} */\n      const transpiled = this.transpile(v, getParams, translation);\n      // set \"b.c\" to `transpiled`\n      result = setValue(result, p, transpiled);\n    });\n    return result;\n  }\n  /**\n   * @protected\n   * @param {?} value\n   * @param {?=} params\n   * @param {?=} translation\n   * @return {?}\n   */\n  handleArray(value, params = {}, translation) {\n    return value.map(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    v => this.transpile(v, params, translation));\n  }\n}\n/** @nocollapse */\n\n/**\n * @param {?=} userConfig\n * @return {?}\n */\nfunction resolveMatcher(userConfig) {\n  const [start, end] = userConfig && userConfig.interpolation ? userConfig.interpolation : defaultConfig.interpolation;\n  return new RegExp(`${start}(.*?)${end}`, 'g');\n}\n/**\n * @param {?} argsString\n * @return {?}\n */\nfunction getFunctionArgs(argsString) {\n  /** @type {?} */\n  const splitted = argsString ? argsString.split(',') : [];\n  /** @type {?} */\n  const args = [];\n  for (let i = 0; i < splitted.length; i++) {\n    /** @type {?} */\n    let value = splitted[i].trim();\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n    args.push(value);\n  }\n  return args;\n}\nlet FunctionalTranspiler = /*#__PURE__*/(() => {\n  class FunctionalTranspiler extends DefaultTranspiler {\n    /**\n     * @param {?} injector\n     */\n    constructor(injector) {\n      super();\n      this.injector = injector;\n    }\n    /**\n     * @param {?} value\n     * @param {?=} params\n     * @param {?=} translation\n     * @return {?}\n     */\n    transpile(value, params = {}, translation) {\n      /** @type {?} */\n      let transpiled = value;\n      if (isString(value)) {\n        transpiled = value.replace(/\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g,\n        /**\n        * @param {?} match\n        * @param {?} functionName\n        * @param {?} args\n        * @return {?}\n        */\n        (match, functionName, args) => {\n          try {\n            /** @type {?} */\n            const func = this.injector.get(functionName);\n            return func.transpile(...getFunctionArgs(args));\n          } catch (e) {\n            /** @type {?} */\n            let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n            if (e.message.includes('NullInjectorError')) {\n              message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n            }\n            throw new Error(message);\n          }\n        });\n      }\n      return super.transpile(transpiled, params, translation);\n    }\n  }\n  FunctionalTranspiler.Éµfac = function FunctionalTranspiler_Factory(t) {\n    return new (t || FunctionalTranspiler)(Éµngcc0.ÉµÉµinject(Éµngcc0.Injector));\n  };\n  FunctionalTranspiler.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: FunctionalTranspiler,\n    factory: FunctionalTranspiler.Éµfac\n  });\n  /** @nocollapse */\n  return FunctionalTranspiler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco-missing-handler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\nlet DefaultHandler = /*#__PURE__*/(() => {\n  class DefaultHandler {\n    /**\n     * @param {?} key\n     * @param {?} config\n     * @return {?}\n     */\n    handle(key, config) {\n      if (config.missingHandler.logMissingKey && !config.prodMode) {\n        /** @type {?} */\n        const msg = `Missing translation for '${key}'`;\n        console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n      }\n      return key;\n    }\n  }\n  DefaultHandler.Éµfac = function DefaultHandler_Factory(t) {\n    return new (t || DefaultHandler)();\n  };\n  DefaultHandler.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: DefaultHandler,\n    factory: DefaultHandler.Éµfac\n  });\n\n  /**\n   * @fileoverview added by tsickle\n   * Generated from: lib/transloco.interceptor.ts\n   * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n  /** @type {?} */\n  return DefaultHandler;\n})();\nconst TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\nlet DefaultInterceptor = /*#__PURE__*/(() => {\n  class DefaultInterceptor {\n    /**\n     * @param {?} translation\n     * @param {?} lang\n     * @return {?}\n     */\n    preSaveTranslation(translation, lang) {\n      return translation;\n    }\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?} lang\n     * @return {?}\n     */\n    preSaveTranslationKey(key, value, lang) {\n      return value;\n    }\n  }\n  DefaultInterceptor.Éµfac = function DefaultInterceptor_Factory(t) {\n    return new (t || DefaultInterceptor)();\n  };\n  DefaultInterceptor.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: DefaultInterceptor,\n    factory: DefaultInterceptor.Éµfac\n  });\n\n  /**\n   * @fileoverview added by tsickle\n   * Generated from: lib/transloco-fallback-strategy.ts\n   * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n  /** @type {?} */\n  return DefaultInterceptor;\n})();\nconst TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken('TRANSLOCO_FALLBACK_STRATEGY');\nclass DefaultFallbackStrategy {\n  /**\n   * @param {?} userConfig\n   */\n  constructor(userConfig) {\n    this.userConfig = userConfig;\n  }\n  /**\n   * @param {?} failedLang\n   * @return {?}\n   */\n  getNextLangs(failedLang) {\n    /** @type {?} */\n    const fallbackLang = this.userConfig.fallbackLang;\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n}\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/merge-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} defaultConfig\n * @param {?} userConfig\n * @return {?}\n */\nfunction mergeConfig(defaultConfig, userConfig) {\n  return Object.assign({}, defaultConfig, userConfig, {\n    missingHandler: Object.assign({}, defaultConfig.missingHandler, userConfig.missingHandler),\n    flatten: Object.assign({}, defaultConfig.flatten, userConfig.flatten)\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/shared.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\n/**\n * @param {?} lang\n * @return {?}\n */\nfunction getScopeFromLang(lang) {\n  if (!lang) {\n    return '';\n  }\n  /** @type {?} */\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\n/**\n * @param {?} lang\n * @return {?}\n */\nfunction getLangFromScope(lang) {\n  if (!lang) {\n    return '';\n  }\n  /** @type {?} */\n  const split = lang.split('/');\n  return split.pop();\n}\n/**\n * \\@example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n * @param {?} str\n * @param {?} value\n * @param {?=} char\n * @return {?}\n */\nfunction getPipeValue(str, value, char = '|') {\n  if (isString(str)) {\n    /** @type {?} */\n    const splitted = str.split(char);\n    /** @type {?} */\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n  return [false, ''];\n}\n/**\n * @param {?} service\n * @param {?} lang\n * @return {?}\n */\nfunction shouldListenToLangChanges(service, lang) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n  if (hasStatic === false) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return service.config.reRenderOnLangChange;\n  }\n  // We have 'lang|static' so don't listen to lang changes\n  return false;\n}\n/**\n * @param {?} listenToLangChange\n * @return {?}\n */\nfunction listenOrNotOperator(listenToLangChange) {\n  return listenToLangChange ?\n  /**\n  * @param {?} source\n  * @return {?}\n  */\n  source => source : take(1);\n}\n/**\n * @param {?} inlineLoader\n * @param {?} scope\n * @return {?}\n */\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce(\n  /**\n  * @param {?} acc\n  * @param {?} lang\n  * @return {?}\n  */\n  (acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n/**\n * @param {?} providerScope\n * @param {?} scope\n * @return {?}\n */\nfunction resolveInlineLoader(providerScope, scope) {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : null;\n}\n/**\n * @param {?} lang\n * @return {?}\n */\nfunction getEventPayload(lang) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang),\n    lang\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/resolve-loader.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} path\n * @param {?} mainLoader\n * @param {?} inlineLoader\n * @param {?} data\n * @return {?}\n */\nfunction resolveLoader(path, mainLoader, inlineLoader, data) {\n  if (inlineLoader) {\n    /** @type {?} */\n    const pathLoader = inlineLoader[path];\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n    return inlineLoader[path]().then(\n    /**\n    * @param {?} res\n    * @return {?}\n    */\n    res => res.default ? res.default : res);\n  }\n  return mainLoader.getTranslation(path, data);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/get-fallbacks-loaders.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} mainPath\n * @param {?} fallbackPath\n * @param {?} mainLoader\n * @param {?} inlineLoader\n * @param {?} data\n * @return {?}\n */\nfunction getFallbacksLoaders(mainPath, fallbackPath, mainLoader, inlineLoader, data) {\n  return [mainPath, fallbackPath].map(\n  /**\n  * @param {?} path\n  * @return {?}\n  */\n  path => {\n    /** @type {?} */\n    const loader = resolveLoader(path, mainLoader, inlineLoader, data);\n    return from(loader).pipe(map(\n    /**\n    * @param {?} translation\n    * @return {?}\n    */\n    translation => ({\n      translation,\n      lang: path\n    })));\n  });\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nlet service;\n/**\n * @template T\n * @param {?} key\n * @param {?=} params\n * @param {?=} lang\n * @return {?}\n */\nfunction translate(key, params = {}, lang) {\n  return service.translate(key, params, lang);\n}\nclass TranslocoService {\n  /**\n   * @param {?} loader\n   * @param {?} parser\n   * @param {?} missingHandler\n   * @param {?} interceptor\n   * @param {?} userConfig\n   * @param {?} fallbackStrategy\n   */\n  constructor(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {\n    this.loader = loader;\n    this.parser = parser;\n    this.missingHandler = missingHandler;\n    this.interceptor = interceptor;\n    this.userConfig = userConfig;\n    this.fallbackStrategy = fallbackStrategy;\n    this.translations = new Map();\n    this.cache = new Map();\n    this.firstFallbackLang = null;\n    this.availableLangs = [];\n    this.isResolvedMissingOnce = false;\n    this.events = new Subject();\n    this.events$ = this.events.asObservable();\n    this.failedLangs = new Set();\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n    service = this;\n    this.mergedConfig = mergeConfig(defaultConfig, userConfig);\n    this.setAvailableLangs(this.mergedConfig.availableLangs);\n    this.setFallbackLangForMissingTranslation(this.mergedConfig);\n    this.setDefaultLang(this.mergedConfig.defaultLang);\n    this.lang = new BehaviorSubject(this.getDefaultLang());\n    // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n    this.langChanges$ = this.lang.asObservable();\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n    this.subscription = this.events$.subscribe(\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        // Handle scoped lang\n        /** @type {?} */\n        const lang = getLangFromScope(e.payload.lang);\n        this.setActiveLang(lang);\n      }\n    });\n  }\n  /**\n   * @return {?}\n   */\n  get config() {\n    return this.mergedConfig;\n  }\n  /**\n   * @return {?}\n   */\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n  /**\n   * @param {?} lang\n   * @return {?}\n   */\n  setDefaultLang(lang) {\n    this.defaultLang = lang;\n  }\n  /**\n   * @return {?}\n   */\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n  /**\n   * @template THIS\n   * @this {THIS}\n   * @param {?} lang\n   * @return {THIS}\n   */\n  setActiveLang(lang) {\n    /** @type {?} */this.lang.next(lang);\n    /** @type {?} */this.parser.onLangChanged && /** @type {?} */this.parser.onLangChanged(lang);\n    return (/** @type {?} */this\n    );\n  }\n  /**\n   * @param {?} langs\n   * @return {?}\n   */\n  setAvailableLangs(langs) {\n    this.availableLangs = langs;\n  }\n  /**\n   * Gets the available languages.\n   *\n   * @return {?}\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n  /**\n   * @param {?} path\n   * @param {?=} options\n   * @return {?}\n   */\n  load(path, options = {}) {\n    if (this.cache.has(path) === false) {\n      /** @type {?} */\n      let loadTranslation;\n      /** @type {?} */\n      const isScope = this._isLangScoped(path);\n      /** @type {?} */\n      const scope = isScope ? getScopeFromLang(path) : null;\n      if (this.useFallbackTranslation(path)) {\n        // if the path is scope the fallback should be `scope/fallbackLang`;\n        /** @type {?} */\n        const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n        /** @type {?} */\n        const loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, {\n          scope\n        });\n        loadTranslation = forkJoin(loaders);\n      } else {\n        /** @type {?} */\n        const loader = resolveLoader(path, this.loader, options.inlineLoader, {\n          scope\n        });\n        loadTranslation = from(loader);\n      }\n      /** @type {?} */\n      const load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap(\n      /**\n      * @param {?} translation\n      * @return {?}\n      */\n      translation => {\n        if (Array.isArray(translation)) {\n          translation.forEach(\n          /**\n          * @param {?} t\n          * @return {?}\n          */\n          t => {\n            this.handleSuccess(t.lang, t.translation);\n            // Save the fallback in cache so we'll not create a redundant request\n            if (t.lang !== path) {\n              this.cache.set(t.lang, of({}));\n            }\n          });\n          return;\n        }\n        this.handleSuccess(path, translation);\n      }), catchError(\n      /**\n      * @return {?}\n      */\n      () => this.handleFailure(path, options)), shareReplay(1));\n      this.cache.set(path, load$);\n    }\n    return this.cache.get(path);\n  }\n  /**\n   * Gets the instant translated value of a key\n   *\n   * \\@example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   * @template T\n   * @param {?} key\n   * @param {?=} params\n   * @param {?=} lang\n   * @return {?}\n   */\n  translate(key, params = {}, lang = this.getActiveLang()) {\n    if (!key) return (/** @type {?} */key\n    );\n    const {\n      scope,\n      resolveLang\n    } = this.resolveLangAndScope(lang);\n    if (Array.isArray(key)) {\n      return (/** @type {?} */key.map(\n        /**\n        * @param {?} k\n        * @return {?}\n        */\n        k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang))\n      );\n    }\n    key = scope ? `${scope}.${key}` : key;\n    /** @type {?} */\n    const translation = this.getTranslation(resolveLang);\n    /** @type {?} */\n    const value = translation[key];\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n    return this.parser.transpile(value, params, translation);\n  }\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * \\@example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   * @template T\n   * @param {?} key\n   * @param {?=} params\n   * @param {?=} lang\n   * @param {?=} _isObject\n   * @return {?}\n   */\n  selectTranslate(key, params, lang, _isObject = false) {\n    /** @type {?} */\n    let inlineLoader = null;\n    /** @type {?} */\n    const load =\n    /**\n    * @param {?} lang\n    * @param {?=} options\n    * @return {?}\n    */\n    (lang, options) => this.load(lang, options).pipe(map(\n    /**\n    * @return {?}\n    */\n    () => _isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)));\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(\n      /**\n      * @param {?} lang\n      * @return {?}\n      */\n      lang => load(lang)));\n    }\n    if (isScopeObject(lang)) {\n      // it's a scope object.\n      /** @type {?} */\n      const providerScope = /** @type {?} */lang;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n    lang = /** @type {?} */lang;\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    }\n    // it's a scope\n    /** @type {?} */\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(\n    /**\n    * @param {?} lang\n    * @return {?}\n    */\n    lang => load(`${scope}/${lang}`, {\n      inlineLoader\n    })));\n  }\n  /**\n   * Whether the scope with lang\n   *\n   * \\@example\n   *\n   * todos/en => true\n   * todos => false\n   * @private\n   * @param {?} lang\n   * @return {?}\n   */\n  isScopeWithLang(lang) {\n    return this.isLang(getLangFromScope(lang));\n  }\n  /**\n   * @template T\n   * @param {?} key\n   * @param {?=} params\n   * @param {?=} lang\n   * @return {?}\n   */\n  translateObject(key, params, lang = this.getActiveLang()) {\n    if (isString(key) || Array.isArray(key)) {\n      if (Array.isArray(key)) {\n        return (/** @type {?} */key.map(\n          /**\n          * @param {?} k\n          * @return {?}\n          */\n          k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang))\n        );\n      }\n      const {\n        resolveLang,\n        scope\n      } = this.resolveLangAndScope(lang);\n      /** @type {?} */\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n      /** @type {?} */\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n    }\n    /** @type {?} */\n    const translations = [];\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n    return translations;\n  }\n  /**\n   * @template T\n   * @param {?} key\n   * @param {?=} params\n   * @param {?=} lang\n   * @return {?}\n   */\n  selectTranslateObject(key, params, lang) {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate(key, params, lang, true);\n    }\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n    return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map(\n    /**\n    * @param {?} value\n    * @return {?}\n    */\n    value => {\n      /** @type {?} */\n      const translations = [value];\n      for (const [_key, _params] of rest) {\n        translations.push(this.translateObject(_key, _params, lang));\n      }\n      return translations;\n    }));\n  }\n  /**\n   * @param {?=} langOrScope\n   * @return {?}\n   */\n  getTranslation(langOrScope) {\n    if (langOrScope) {\n      if (this.isLang(langOrScope)) {\n        return this.translations.get(langOrScope) || {};\n      } else {\n        // This is a scope, build the scope value from the translation object\n        const {\n          scope,\n          resolveLang\n        } = this.resolveLangAndScope(langOrScope);\n        /** @type {?} */\n        const translation = this.translations.get(resolveLang) || {};\n        return this.getObjectByKey(translation, scope);\n      }\n    }\n    return this.translations;\n  }\n  /**\n   * Gets an object of translations for a given language\n   *\n   * \\@example\n   *\n   * selectTranslation().subscribe() - will return the current lang translation\n   * selectTranslation('es').subscribe()\n   * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n   * selectTranslation('admin-page/es').subscribe()\n   * @param {?=} lang\n   * @return {?}\n   */\n  selectTranslation(lang) {\n    /** @type {?} */\n    let language$ = this.langChanges$;\n    if (lang) {\n      /** @type {?} */\n      const scopeLangSpecified = getLangFromScope(lang) !== lang;\n      if (this.isLang(lang) || scopeLangSpecified) {\n        language$ = of(lang);\n      } else {\n        language$ = this.langChanges$.pipe(map(\n        /**\n        * @param {?} currentLang\n        * @return {?}\n        */\n        currentLang => `${lang}/${currentLang}`));\n      }\n    }\n    return language$.pipe(switchMap(\n    /**\n    * @param {?} language\n    * @return {?}\n    */\n    language => this.load(language).pipe(map(\n    /**\n    * @return {?}\n    */\n    () => this.getTranslation(language)))));\n  }\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * \\@example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   * @param {?} translation\n   * @param {?=} lang\n   * @param {?=} options\n   * @return {?}\n   */\n  setTranslation(translation, lang = this.getActiveLang(), options = {}) {\n    /** @type {?} */\n    const defaults = {\n      merge: true,\n      emitChange: true\n    };\n    /** @type {?} */\n    const mergedOptions = Object.assign({}, defaults, options);\n    /** @type {?} */\n    const scope = getScopeFromLang(lang);\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     * @type {?}\n     */\n    let flattenScopeOrTranslation = translation;\n    // Merged the scoped language into the active language\n    if (scope) {\n      /** @type {?} */\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({\n        [key]: translation\n      });\n    }\n    /** @type {?} */\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n    /** @type {?} */\n    const mergedTranslation = Object.assign({}, mergedOptions.merge && this.getTranslation(currentLang), flattenScopeOrTranslation);\n    /** @type {?} */\n    const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    /** @type {?} */\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n  /**\n   * Sets translation key with given value\n   *\n   * \\@example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n   * @param {?} key\n   * @param {?} value\n   * @param {?=} lang\n   * @param {?=} options\n   * @return {?}\n   */\n  setTranslationKey(key, value, lang = this.getActiveLang(),\n  // Todo: Use Omit and merge options and lang to one object in v3\n  options = {}) {\n    /** @type {?} */\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    /** @type {?} */\n    const newValue = {\n      [key]: withHook\n    };\n    this.setTranslation(newValue, lang, Object.assign({}, options, {\n      merge: true\n    }));\n  }\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param {?} __0\n   * @return {?}\n   */\n  setFallbackLangForMissingTranslation({\n    fallbackLang\n  }) {\n    /** @type {?} */\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n    if (this.useFallbackTranslation(lang) && fallbackLang) {\n      this.firstFallbackLang = lang;\n    }\n  }\n  /**\n   * \\@internal\n   * @param {?} key\n   * @param {?} value\n   * @param {?=} params\n   * @return {?}\n   */\n  _handleMissingKey(key, value, params) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n    if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      /** @type {?} */\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n  /**\n   * \\@internal\n   * @param {?} lang\n   * @return {?}\n   */\n  _isLangScoped(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @param {?} lang\n   * @return {?}\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n  isLang(lang) {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n  /**\n   * \\@internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   * @param {?} path\n   * @param {?=} inlineLoader\n   * @return {?}\n   */\n  _loadDependencies(path, inlineLoader) {\n    /** @type {?} */\n    const mainLang = getLangFromScope(path);\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest(this.load(mainLang), this.load(path, {\n        inlineLoader\n      }));\n    }\n    return this.load(path, {\n      inlineLoader\n    });\n  }\n  /**\n   * \\@internal\n   * @param {?} langOrScope\n   * @return {?}\n   */\n  _completeScopeWithLang(langOrScope) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n    return langOrScope;\n  }\n  /**\n   * \\@internal\n   * @param {?} scope\n   * @param {?} alias\n   * @return {?}\n   */\n  _setScopeAlias(scope, alias) {\n    if (!this.mergedConfig.scopeMapping) {\n      this.mergedConfig.scopeMapping = {};\n    }\n    this.mergedConfig.scopeMapping[scope] = alias;\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n  /**\n   * @private\n   * @param {?} lang\n   * @return {?}\n   */\n  isLoadedTranslation(lang) {\n    return size(this.getTranslation(lang));\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n  getAvailableLangsIds() {\n    /** @type {?} */\n    const first = this.getAvailableLangs()[0];\n    if (isString(first)) {\n      return (/** @type {?} */this.getAvailableLangs()\n      );\n    }\n    return (/** @type {?} */this.getAvailableLangs().map(\n      /**\n      * @param {?} l\n      * @return {?}\n      */\n      l => l.id)\n    );\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n  getMissingHandlerData() {\n    return Object.assign({}, this.config, {\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    });\n  }\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   * @private\n   * @param {?=} lang\n   * @return {?}\n   */\n  useFallbackTranslation(lang) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n  /**\n   * @private\n   * @param {?} lang\n   * @param {?} translation\n   * @return {?}\n   */\n  handleSuccess(lang, translation) {\n    this.setTranslation(translation, lang, {\n      emitChange: false\n    });\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(\n    /**\n    * @param {?} l\n    * @return {?}\n    */\n    l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n  /**\n   * @private\n   * @param {?} lang\n   * @param {?} loadOptions\n   * @return {?}\n   */\n  handleFailure(lang, loadOptions) {\n    // When starting to load a first choice language, initialize\n    // the failed counter and resolve the fallback langs.\n    if (isNil(loadOptions.failedCounter)) {\n      loadOptions.failedCounter = 0;\n      if (!loadOptions.fallbackLangs) {\n        loadOptions.fallbackLangs = this.fallbackStrategy.getNextLangs(lang);\n      }\n    }\n    /** @type {?} */\n    const splitted = lang.split('/');\n    /** @type {?} */\n    const fallbacks = loadOptions.fallbackLangs;\n    /** @type {?} */\n    const nextLang = fallbacks[loadOptions.failedCounter];\n    this.failedLangs.add(lang);\n    // This handles the case where a loaded fallback language is requested again\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n    /** @type {?} */\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n    if (!nextLang || isFallbackLang) {\n      /** @type {?} */\n      let msg = `Unable to load translation and all the fallback languages`;\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n      throw new Error(msg);\n    }\n    /** @type {?} */\n    let resolveLang = nextLang;\n    // if it's scoped lang\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n    loadOptions.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n    return this.load(resolveLang, loadOptions);\n  }\n  /**\n   * @private\n   * @param {?} scope\n   * @return {?}\n   */\n  getMappedScope(scope) {\n    const {\n      scopeMapping = {}\n    } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   * @private\n   * @param {?} lang\n   * @return {?}\n   */\n  resolveLangAndScope(lang) {\n    /** @type {?} */\n    let resolveLang = lang;\n    /** @type {?} */\n    let scope;\n    if (this._isLangScoped(lang)) {\n      // en for example\n      /** @type {?} */\n      const langFromScope = getLangFromScope(lang);\n      // en is lang\n      /** @type {?} */\n      const hasLang = this.isLang(langFromScope);\n      // take en\n      resolveLang = hasLang ? langFromScope : this.getActiveLang();\n      // find the scope\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n    return {\n      scope,\n      resolveLang\n    };\n  }\n  /**\n   * @private\n   * @param {?} translation\n   * @param {?} key\n   * @return {?}\n   */\n  getObjectByKey(translation, key) {\n    /** @type {?} */\n    const result = {};\n    /** @type {?} */\n    const prefix = `${key}.`;\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n    return result;\n  }\n  /**\n   * @private\n   * @param {?} key\n   * @return {?}\n   */\n  getEntries(key) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n}\nTranslocoService.Éµfac = function TranslocoService_Factory(t) {\n  return new (t || TranslocoService)(Éµngcc0.ÉµÉµinject(TRANSLOCO_LOADER, 8), Éµngcc0.ÉµÉµinject(TRANSLOCO_TRANSPILER), Éµngcc0.ÉµÉµinject(TRANSLOCO_MISSING_HANDLER), Éµngcc0.ÉµÉµinject(TRANSLOCO_INTERCEPTOR), Éµngcc0.ÉµÉµinject(TRANSLOCO_CONFIG), Éµngcc0.ÉµÉµinject(TRANSLOCO_FALLBACK_STRATEGY));\n};\nTranslocoService.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n  token: TranslocoService,\n  factory: TranslocoService.Éµfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\n/** @nocollapse */TranslocoService.ngInjectableDef = defineInjectable({\n  factory: function TranslocoService_Factory() {\n    return new TranslocoService(inject(TRANSLOCO_LOADER, 8), inject(TRANSLOCO_TRANSPILER), inject(TRANSLOCO_MISSING_HANDLER), inject(TRANSLOCO_INTERCEPTOR), inject(TRANSLOCO_CONFIG), inject(TRANSLOCO_FALLBACK_STRATEGY));\n  },\n  token: TranslocoService,\n  providedIn: \"root\"\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/loader-component.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet TranslocoLoaderComponent = /*#__PURE__*/(() => {\n  class TranslocoLoaderComponent {}\n  TranslocoLoaderComponent.Éµfac = function TranslocoLoaderComponent_Factory(t) {\n    return new (t || TranslocoLoaderComponent)();\n  };\n  TranslocoLoaderComponent.Éµcmp = /*@__PURE__*/Éµngcc0.ÉµÉµdefineComponent({\n    type: TranslocoLoaderComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      html: \"html\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[1, \"transloco-loader-template\", 3, \"innerHTML\"]],\n    template: function TranslocoLoaderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµelement(0, \"div\", 0);\n      }\n      if (rf & 2) {\n        Éµngcc0.ÉµÉµproperty(\"innerHTML\", ctx.html, Éµngcc0.ÉµÉµsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n  return TranslocoLoaderComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/template-handler.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TemplateHandler {\n  /**\n   * @param {?} view\n   * @param {?} vcr\n   */\n  constructor(view, vcr) {\n    this.view = view;\n    this.vcr = vcr;\n    this.injector = this.vcr.injector;\n  }\n  /**\n   * @return {?}\n   */\n  attachView() {\n    if (this.view instanceof TemplateRef) {\n      this.vcr.createEmbeddedView(this.view);\n    } else if (isString(this.view)) {\n      /** @type {?} */\n      const componentRef = this.createComponent(TranslocoLoaderComponent);\n      componentRef.instance.html = this.view;\n      componentRef.hostView.detectChanges();\n    } else {\n      this.createComponent(this.view);\n    }\n  }\n  /**\n   * @return {?}\n   */\n  detachView() {\n    this.vcr.clear();\n  }\n  /**\n   * @private\n   * @template T\n   * @param {?} cmp\n   * @return {?}\n   */\n  createComponent(cmp) {\n    /** @type {?} */\n    const cfr = this.injector.get(ComponentFactoryResolver);\n    /** @type {?} */\n    const factory = cfr.resolveComponentFactory(cmp);\n    return this.vcr.createComponent(factory);\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco-lang.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_LANG = new InjectionToken('TRANSLOCO_LANG');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco-loading-template.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_LOADING_TEMPLATE = new InjectionToken('TRANSLOCO_LOADING_TEMPLATE');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco-scope.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_SCOPE = new InjectionToken('TRANSLOCO_SCOPE');\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/lang-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass LangResolver {\n  constructor() {\n    this.initialized = false;\n  }\n  // inline => provider => active\n  /**\n   * @param {?=} __0\n   * @return {?}\n   */\n  resolve({\n    inline,\n    provider,\n    active\n  } = {\n    inline: undefined,\n    provider: undefined,\n    active: undefined\n  }) {\n    /** @type {?} */\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n    if (provider) {\n      const [_, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n    if (inline) {\n      const [_, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n    this.initialized = true;\n    return lang;\n  }\n  /**\n   *\n   * Resolve the lang\n   *\n   * \\@example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   * @param {?} lang\n   * @return {?}\n   */\n  resolveLangBasedOnScope(lang) {\n    /** @type {?} */\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * \\@example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   * @param {?} lang\n   * @param {?} scope\n   * @return {?}\n   */\n  resolveLangPath(lang, scope) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/scope-resolver.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScopeResolver {\n  /**\n   * @param {?} translocoService\n   */\n  constructor(translocoService) {\n    this.translocoService = translocoService;\n  }\n  // inline => provider\n  /**\n   * @param {?=} __0\n   * @return {?}\n   */\n  resolve({\n    inline,\n    provider\n  } = {\n    inline: undefined,\n    provider: undefined\n  }) {\n    if (inline) {\n      return inline;\n    }\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const {\n          scope,\n          alias = toCamelCase(scope)\n        } = /** @type {?} */provider;\n        this.translocoService._setScopeAlias(scope, alias);\n        return scope;\n      }\n      return (/** @type {?} */provider\n      );\n    }\n    return undefined;\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet TranslocoDirective = /*#__PURE__*/(() => {\n  class TranslocoDirective {\n    /**\n     * @param {?} translocoService\n     * @param {?} tpl\n     * @param {?} providerScope\n     * @param {?} providerLang\n     * @param {?} providedLoadingTpl\n     * @param {?} vcr\n     * @param {?} cdr\n     * @param {?} host\n     */\n    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host) {\n      this.translocoService = translocoService;\n      this.tpl = tpl;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.providedLoadingTpl = providedLoadingTpl;\n      this.vcr = vcr;\n      this.cdr = cdr;\n      this.host = host;\n      this.translationMemo = {};\n      this.params = {};\n      this.loaderTplHandler = null;\n      // Whether we already rendered the view once\n      this.initialized = false;\n      this.langResolver = new LangResolver();\n      this.scopeResolver = new ScopeResolver(this.translocoService);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n      /** @type {?} */\n      const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n      this.subscription = this.translocoService.langChanges$.pipe(switchMap(\n      /**\n      * @param {?} activeLang\n      * @return {?}\n      */\n      activeLang => {\n        /** @type {?} */\n        const lang = this.langResolver.resolve({\n          inline: this.inlineLang,\n          provider: this.providerLang,\n          active: activeLang\n        });\n        return Array.isArray(this.providerScope) ? forkJoin( /** @type {?} */this.providerScope.map(\n        /**\n        * @param {?} providerScope\n        * @return {?}\n        */\n        providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n      }), listenOrNotOperator(listenToLangChange)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.tpl === null ? this.simpleStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n        this.cdr.markForCheck();\n        this.initialized = true;\n      });\n      /** @type {?} */\n      const loadingTpl = this.getLoadingTpl();\n      if (!this.initialized && loadingTpl) {\n        this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n        this.loaderTplHandler.attachView();\n      }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n      // We need to support dynamic keys/params, so if this is not the first change CD cycle\n      // we need to run the function again in order to update the value\n      /** @type {?} */\n      const notInit = Object.keys(changes).some(\n      /**\n      * @param {?} v\n      * @return {?}\n      */\n      v => changes[v].firstChange === false);\n      notInit && this.simpleStrategy();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    simpleStrategy() {\n      this.detachLoader();\n      this.host.nativeElement.innerText = this.translocoService.translate(this.key, this.params, this.currentLang);\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} read\n     * @return {?}\n     */\n    structuralStrategy(lang, read) {\n      this.translationMemo = {};\n      if (this.view) {\n        // when the lang changes we need to change the reference so Angular will update the view\n        this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n        this.view.context['currentLang'] = this.currentLang;\n      } else {\n        this.detachLoader();\n        this.view = this.vcr.createEmbeddedView(this.tpl, {\n          $implicit: this.getTranslateFn(lang, read),\n          currentLang: this.currentLang\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} read\n     * @return {?}\n     */\n    getTranslateFn(lang, read) {\n      return (\n        /**\n        * @param {?} key\n        * @param {?} params\n        * @return {?}\n        */\n        (key, params) => {\n          /** @type {?} */\n          const withRead = read ? `${read}.${key}` : key;\n          /** @type {?} */\n          const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n          if (this.translationMemo.hasOwnProperty(withParams)) {\n            return this.translationMemo[withParams].value;\n          }\n          this.translationMemo[withParams] = {\n            params,\n            value: this.translocoService.translate(withRead, params, lang)\n          };\n          return this.translationMemo[withParams].value;\n        }\n      );\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getLoadingTpl() {\n      return this.inlineTpl || this.providedLoadingTpl;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.subscription && this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    detachLoader() {\n      this.loaderTplHandler && this.loaderTplHandler.detachView();\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} providerScope\n     * @return {?}\n     */\n    resolveScope(lang, providerScope) {\n      /** @type {?} */\n      let resolvedScope = this.scopeResolver.resolve({\n        inline: this.inlineScope,\n        provider: providerScope\n      });\n      this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n      /** @type {?} */\n      const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n      return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n  }\n  TranslocoDirective.Éµfac = function TranslocoDirective_Factory(t) {\n    return new (t || TranslocoDirective)(Éµngcc0.ÉµÉµdirectiveInject(TranslocoService), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.TemplateRef, 8), Éµngcc0.ÉµÉµdirectiveInject(TRANSLOCO_SCOPE, 8), Éµngcc0.ÉµÉµdirectiveInject(TRANSLOCO_LANG, 8), Éµngcc0.ÉµÉµdirectiveInject(TRANSLOCO_LOADING_TEMPLATE, 8), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ViewContainerRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ChangeDetectorRef), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ElementRef));\n  };\n  TranslocoDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: TranslocoDirective,\n    selectors: [[\"\", \"transloco\", \"\"]],\n    inputs: {\n      params: [\"translocoParams\", \"params\"],\n      key: [\"transloco\", \"key\"],\n      inlineScope: [\"translocoScope\", \"inlineScope\"],\n      inlineRead: [\"translocoRead\", \"inlineRead\"],\n      inlineLang: [\"translocoLang\", \"inlineLang\"],\n      inlineTpl: [\"translocoLoadingTpl\", \"inlineTpl\"]\n    },\n    features: [Éµngcc0.ÉµÉµNgOnChangesFeature]\n  });\n  /** @nocollapse */\n  return TranslocoDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet TranslocoPipe = /*#__PURE__*/(() => {\n  class TranslocoPipe {\n    /**\n     * @param {?} translocoService\n     * @param {?} providerScope\n     * @param {?} providerLang\n     * @param {?} cdr\n     */\n    constructor(translocoService, providerScope, providerLang, cdr) {\n      this.translocoService = translocoService;\n      this.providerScope = providerScope;\n      this.providerLang = providerLang;\n      this.cdr = cdr;\n      this.subscription = null;\n      this.lastValue = '';\n      this.langResolver = new LangResolver();\n      this.scopeResolver = new ScopeResolver(this.translocoService);\n      this.listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang);\n    }\n    // null is for handling strict mode + async pipe types https://github.com/ngneat/transloco/issues/311\n    /**\n     * @param {?} key\n     * @param {?=} params\n     * @param {?=} inlineLang\n     * @return {?}\n     */\n    transform(key, params, inlineLang) {\n      if (!key) {\n        return key;\n      }\n      /** @type {?} */\n      const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n      if (keyName === this.lastKey) {\n        return this.lastValue;\n      }\n      this.lastKey = keyName;\n      this.subscription && this.subscription.unsubscribe();\n      this.subscription = this.translocoService.langChanges$.pipe(switchMap(\n      /**\n      * @param {?} activeLang\n      * @return {?}\n      */\n      activeLang => {\n        /** @type {?} */\n        const lang = this.langResolver.resolve({\n          inline: inlineLang,\n          provider: this.providerLang,\n          active: activeLang\n        });\n        return Array.isArray(this.providerScope) ? forkJoin( /** @type {?} */this.providerScope.map(\n        /**\n        * @param {?} providerScope\n        * @return {?}\n        */\n        providerScope => this.resolveScope(lang, providerScope))) : this.resolveScope(lang, this.providerScope);\n      }), listenOrNotOperator(this.listenToLangChange)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => this.updateValue(key, params));\n      return this.lastValue;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n      this.subscription && this.subscription.unsubscribe();\n    }\n    /**\n     * @private\n     * @param {?} key\n     * @param {?=} params\n     * @return {?}\n     */\n    updateValue(key, params) {\n      /** @type {?} */\n      const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n      this.lastValue = this.translocoService.translate(key, params, lang);\n      this.cdr.markForCheck();\n    }\n    /**\n     * @private\n     * @param {?} lang\n     * @param {?} providerScope\n     * @return {?}\n     */\n    resolveScope(lang, providerScope) {\n      /** @type {?} */\n      let resolvedScope = this.scopeResolver.resolve({\n        inline: undefined,\n        provider: providerScope\n      });\n      this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n      /** @type {?} */\n      const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n      return this.translocoService._loadDependencies(this.path, inlineLoader);\n    }\n  }\n  TranslocoPipe.Éµfac = function TranslocoPipe_Factory(t) {\n    return new (t || TranslocoPipe)(Éµngcc0.ÉµÉµdirectiveInject(TranslocoService, 16), Éµngcc0.ÉµÉµdirectiveInject(TRANSLOCO_SCOPE, 24), Éµngcc0.ÉµÉµdirectiveInject(TRANSLOCO_LANG, 24), Éµngcc0.ÉµÉµdirectiveInject(Éµngcc0.ChangeDetectorRef, 16));\n  };\n  TranslocoPipe.Éµpipe = /*@__PURE__*/Éµngcc0.ÉµÉµdefinePipe({\n    name: \"transloco\",\n    type: TranslocoPipe,\n    pure: false\n  });\n  /** @nocollapse */\n  return TranslocoPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst defaultProviders = [{\n  provide: TRANSLOCO_TRANSPILER,\n  useClass: DefaultTranspiler,\n  deps: [TRANSLOCO_CONFIG]\n}, {\n  provide: TRANSLOCO_MISSING_HANDLER,\n  useClass: DefaultHandler\n}, {\n  provide: TRANSLOCO_INTERCEPTOR,\n  useClass: DefaultInterceptor\n}, {\n  provide: TRANSLOCO_FALLBACK_STRATEGY,\n  useClass: DefaultFallbackStrategy,\n  deps: [TRANSLOCO_CONFIG]\n}];\nlet TranslocoModule = /*#__PURE__*/(() => {\n  class TranslocoModule {}\n  TranslocoModule.Éµfac = function TranslocoModule_Factory(t) {\n    return new (t || TranslocoModule)();\n  };\n  TranslocoModule.Éµmod = /*@__PURE__*/Éµngcc0.ÉµÉµdefineNgModule({\n    type: TranslocoModule\n  });\n  TranslocoModule.Éµinj = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjector({\n    providers: [defaultProviders]\n  });\n  return TranslocoModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(TranslocoModule, {\n    declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n    exports: [TranslocoDirective, TranslocoPipe]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transloco-testing.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst TRANSLOCO_TEST_LANGS = new InjectionToken('TRANSLOCO_TEST_LANGS - Available testing languages');\n/** @type {?} */\nconst TRANSLOCO_TEST_OPTIONS = new InjectionToken('TRANSLOCO_TEST_OPTIONS - Testing options');\nlet TestingLoader = /*#__PURE__*/(() => {\n  class TestingLoader {\n    /**\n     * @param {?} langs\n     */\n    constructor(langs) {\n      this.langs = langs;\n    }\n    /**\n     * @param {?} lang\n     * @return {?}\n     */\n    getTranslation(lang) {\n      return of(this.langs[lang]);\n    }\n  }\n  TestingLoader.Éµfac = function TestingLoader_Factory(t) {\n    return new (t || TestingLoader)(Éµngcc0.ÉµÉµinject(TRANSLOCO_TEST_LANGS));\n  };\n  TestingLoader.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: TestingLoader,\n    factory: TestingLoader.Éµfac\n  });\n  /** @nocollapse */\n  return TestingLoader;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} service\n * @param {?=} langs\n * @param {?=} options\n * @return {?}\n */\nfunction initTranslocoService(service, langs = {}, options) {\n  /** @type {?} */\n  const preloadAllLangs =\n  /**\n  * @return {?}\n  */\n  () => options.preloadLangs ? Promise.all(Object.keys(langs).map(\n  /**\n  * @param {?} lang\n  * @return {?}\n  */\n  lang => service.load(lang).toPromise())) : Promise.resolve();\n  return preloadAllLangs;\n}\nlet TranslocoTestingModule = /*#__PURE__*/(() => {\n  class TranslocoTestingModule {\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    static forRoot(options) {\n      return {\n        ngModule: TranslocoTestingModule,\n        providers: [{\n          provide: TRANSLOCO_TEST_LANGS,\n          useValue: options.langs\n        }, {\n          provide: TRANSLOCO_TEST_OPTIONS,\n          useValue: options\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: initTranslocoService,\n          deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n          multi: true\n        }, {\n          provide: TRANSLOCO_LOADER,\n          useClass: TestingLoader\n        }, defaultProviders, {\n          provide: TRANSLOCO_CONFIG,\n          useValue: translocoConfig(Object.assign({\n            prodMode: true,\n            missingHandler: {\n              logMissingKey: false\n            }\n          }, options.translocoConfig))\n        }]\n      };\n    }\n    /**\n     * @deprecated - use forRoot instead\n     * @param {?} langs\n     * @param {?=} config\n     * @param {?=} options\n     * @return {?}\n     */\n    static withLangs(langs, config = {}, options = {}) {\n      return {\n        ngModule: TranslocoTestingModule,\n        providers: [{\n          provide: TRANSLOCO_TEST_LANGS,\n          useValue: langs\n        }, {\n          provide: TRANSLOCO_TEST_OPTIONS,\n          useValue: options\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: initTranslocoService,\n          deps: [TranslocoService, TRANSLOCO_TEST_LANGS, TRANSLOCO_TEST_OPTIONS],\n          multi: true\n        }, {\n          provide: TRANSLOCO_LOADER,\n          useClass: TestingLoader\n        }, defaultProviders, {\n          provide: TRANSLOCO_CONFIG,\n          useValue: translocoConfig(Object.assign({\n            prodMode: true,\n            missingHandler: {\n              logMissingKey: false\n            }\n          }, config))\n        }]\n      };\n    }\n  }\n  TranslocoTestingModule.Éµfac = function TranslocoTestingModule_Factory(t) {\n    return new (t || TranslocoTestingModule)();\n  };\n  TranslocoTestingModule.Éµmod = /*@__PURE__*/Éµngcc0.ÉµÉµdefineNgModule({\n    type: TranslocoTestingModule\n  });\n  TranslocoTestingModule.Éµinj = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjector({\n    imports: [TranslocoModule]\n  });\n  return TranslocoTestingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(TranslocoTestingModule, {\n    exports: [TranslocoModule]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/browser-lang.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n * @return {?}\n */\nfunction getBrowserLang() {\n  /** @type {?} */\n  let browserLang = getBrowserCultureLang();\n  if (isBrowser() === false || !browserLang) {\n    return undefined;\n  }\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n  return browserLang;\n}\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n * @return {?}\n */\nfunction getBrowserCultureLang() {\n  if (isBrowser() === false) {\n    return undefined;\n  }\n  /** @type {?} */\n  const navigator = /** @type {?} */window.navigator;\n  /** @type {?} */\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n  return browserCultureLang;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/types.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngneat-transloco.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { translate, TranslocoService, TranslocoDirective, TranslocoPipe, TranslocoModule, defaultProviders, TRANSLOCO_LOADER, TRANSLOCO_CONFIG, defaultConfig, provideTranslocoConfig, translocoConfig, TRANSLOCO_TRANSPILER, DefaultTranspiler, FunctionalTranspiler, getFunctionArgs, TRANSLOCO_SCOPE, TRANSLOCO_LOADING_TEMPLATE, TRANSLOCO_LANG, TestingLoader, TranslocoTestingModule, TemplateHandler, TRANSLOCO_INTERCEPTOR, TRANSLOCO_FALLBACK_STRATEGY, DefaultFallbackStrategy, TRANSLOCO_MISSING_HANDLER, getBrowserCultureLang, getBrowserLang, getPipeValue, getLangFromScope, getScopeFromLang, getValue, setValue, size, isEmpty, isFunction, isString, isNumber, isObject, coerceArray, toCamelCase, isBrowser, isNil, isDefined, toNumber, isScopeObject, hasInlineLoader, unflatten, flatten, TranslocoLoaderComponent as Éµd, DefaultHandler as Éµc, initTranslocoService as Éµa, DefaultInterceptor as Éµb };\n\n//# sourceMappingURL=ngneat-transloco.js.map","map":null,"metadata":{},"sourceType":"module"}