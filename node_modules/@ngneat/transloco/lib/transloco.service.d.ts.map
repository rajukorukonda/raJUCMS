{"version":3,"file":"transloco.service.d.ts","sources":["transloco.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { OnDestroy } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { TranslocoLoader } from './transloco.loader';\nimport { TranslocoTranspiler } from './transloco.transpiler';\nimport { AvailableLangs, HashMap, InlineLoader, LoadOptions, SetTranslationOptions, TranslateParams, Translation, TranslocoEvents, TranslocoScope } from './types';\nimport { TranslocoConfig } from './transloco.config';\nimport { TranslocoMissingHandler } from './transloco-missing-handler';\nimport { TranslocoInterceptor } from './transloco.interceptor';\nimport { TranslocoFallbackStrategy } from './transloco-fallback-strategy';\nexport declare function translate<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\nexport declare class TranslocoService implements OnDestroy {\n    private loader;\n    private parser;\n    private missingHandler;\n    private interceptor;\n    private userConfig;\n    private fallbackStrategy;\n    private subscription;\n    private translations;\n    private cache;\n    private firstFallbackLang;\n    private defaultLang;\n    private mergedConfig;\n    private availableLangs;\n    private isResolvedMissingOnce;\n    private lang;\n    langChanges$: Observable<string>;\n    private events;\n    events$: Observable<TranslocoEvents>;\n    private failedLangs;\n    constructor(loader: TranslocoLoader, parser: TranslocoTranspiler, missingHandler: TranslocoMissingHandler, interceptor: TranslocoInterceptor, userConfig: TranslocoConfig, fallbackStrategy: TranslocoFallbackStrategy);\n    readonly config: TranslocoConfig;\n    getDefaultLang(): string;\n    setDefaultLang(lang: string): void;\n    getActiveLang(): string;\n    setActiveLang(lang: string): this;\n    setAvailableLangs(langs: AvailableLangs): void;\n    /**\n     * Gets the available languages.\n     *\n     * @returns\n     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n     * depending on how the available languages are set in your module.\n     */\n    getAvailableLangs(): AvailableLangs;\n    load(path: string, options?: LoadOptions): Observable<Translation>;\n    /**\n     * Gets the instant translated value of a key\n     *\n     * @example\n     *\n     * translate<string>('hello')\n     * translate('hello', { value: 'value' })\n     * translate<string[]>(['hello', 'key'])\n     * translate('hello', { }, 'en')\n     * translate('scope.someKey', { }, 'en')\n     */\n    translate<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T;\n    /**\n     * Gets the translated value of a key as observable\n     *\n     * @example\n     *\n     * selectTranslate<string>('hello').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n     *\n     */\n    selectTranslate<T = any>(key: TranslateParams, params?: HashMap, lang?: string | TranslocoScope, _isObject?: boolean): Observable<T>;\n    /**\n     * Whether the scope with lang\n     *\n     * @example\n     *\n     * todos/en => true\n     * todos => false\n     */\n    private isScopeWithLang;\n    /**\n     * Translate the given path that returns an object\n     *\n     * @example\n     *\n     * service.translateObject('path.to.object', {'subpath': { value: 'someValue'}}) => returns translated object\n     *\n     */\n    translateObject<T = any>(key: string, params?: HashMap, lang?: string): T;\n    translateObject<T = any>(key: string[], params?: HashMap, lang?: string): T[];\n    translateObject<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T | T[];\n    translateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): T[];\n    selectTranslateObject<T = any>(key: string, params?: HashMap, lang?: string): Observable<T>;\n    selectTranslateObject<T = any>(key: string[], params?: HashMap, lang?: string): Observable<T[]>;\n    selectTranslateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): Observable<T[]>;\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * getTranslation()\n     * getTranslation('en')\n     * getTranslation('admin-page/en')\n     */\n    getTranslation(): Map<string, Translation>;\n    getTranslation(langOrScope: string): Translation;\n    /**\n     * Gets an object of translations for a given language\n     *\n     * @example\n     *\n     * selectTranslation().subscribe() - will return the current lang translation\n     * selectTranslation('es').subscribe()\n     * selectTranslation('admin-page').subscribe() - will return the current lang scope translation\n     * selectTranslation('admin-page/es').subscribe()\n     */\n    selectTranslation(lang?: string): Observable<Translation>;\n    /**\n     * Sets or merge a given translation object to current lang\n     *\n     * @example\n     *\n     * setTranslation({ ... })\n     * setTranslation({ ... }, 'en')\n     * setTranslation({ ... }, 'es', { merge: false } )\n     * setTranslation({ ... }, 'todos/en', { merge: false } )\n     */\n    setTranslation(translation: Translation, lang?: string, options?: SetTranslationOptions): void;\n    /**\n     * Sets translation key with given value\n     *\n     * @example\n     *\n     * setTranslationKey('key', 'value')\n     * setTranslationKey('key.nested', 'value')\n     * setTranslationKey('key.nested', 'value', 'en')\n     * setTranslationKey('key.nested', 'value', 'en', { emitChange: false } )\n     */\n    setTranslationKey(key: string, value: string, lang?: string, options?: {\n        emitChange?: SetTranslationOptions['emitChange'];\n    }): void;\n    /**\n     * Sets the fallback lang for the currently active language\n     * @param fallbackLang\n     */\n    setFallbackLangForMissingTranslation({ fallbackLang }: Pick<TranslocoConfig, 'fallbackLang'>): void;\n    /**\n     * @internal\n     */\n    _handleMissingKey(key: string, value: any, params?: HashMap): any;\n    /**\n     * @internal\n     */\n    _isLangScoped(lang: string): boolean;\n    /**\n     * Checks if a given string is one of the specified available languages.\n     * @returns\n     * True if the given string is an available language.\n     * False if the given string is not an available language.\n     */\n    isLang(lang: string): boolean;\n    /**\n     * @internal\n     *\n     * We always want to make sure the global lang is loaded\n     * before loading the scope since you can access both via the pipe/directive.\n     */\n    _loadDependencies(path: string, inlineLoader?: InlineLoader): Observable<Translation | Translation[]>;\n    /**\n     * @internal\n     */\n    _completeScopeWithLang(langOrScope: string): string;\n    /**\n     * @internal\n     */\n    _setScopeAlias(scope: string, alias: string): void;\n    ngOnDestroy(): void;\n    private isLoadedTranslation;\n    private getAvailableLangsIds;\n    private getMissingHandlerData;\n    /**\n     * Use a fallback translation set for missing keys of the primary language\n     * This is unrelated to the fallback language (which changes the active language)\n     */\n    private useFallbackTranslation;\n    private handleSuccess;\n    private handleFailure;\n    private getMappedScope;\n    /**\n     * If lang is scope we need to check the following cases:\n     * todos/es => in this case we should take `es` as lang\n     * todos => in this case we should set the active lang as lang\n     */\n    private resolveLangAndScope;\n    private getObjectByKey;\n    private getEntries;\n}\n"]}